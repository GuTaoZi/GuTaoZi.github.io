<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-32x32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gutaozi.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.27.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="原来算法学了这么多吗(＃°Д°)!">
<meta property="og:type" content="article">
<meta property="og:title" content="CS216 算法设计与分析 期末复习">
<meta property="og:url" content="https://gutaozi.github.io/2026/01/11/CS216_Final_Review/index.html">
<meta property="og:site_name" content="GuTao&#39;s Nest">
<meta property="og:description" content="原来算法学了这么多吗(＃°Д°)!">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hliangzhao.cn/static/resources/mathbasis/markov.png">
<meta property="article:published_time" content="2026-01-11T08:44:53.537Z">
<meta property="article:modified_time" content="2026-01-11T08:44:53.589Z">
<meta property="article:author" content="Gu Tao">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hliangzhao.cn/static/resources/mathbasis/markov.png">


<link rel="canonical" href="https://gutaozi.github.io/2026/01/11/CS216_Final_Review/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://gutaozi.github.io/2026/01/11/CS216_Final_Review/","path":"2026/01/11/CS216_Final_Review/","title":"CS216 算法设计与分析 期末复习"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CS216 算法设计与分析 期末复习 | GuTao's Nest</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">GuTao's Nest</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-1-%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D"><span class="nav-number">1.</span> <span class="nav-text">Chapter 1 - 稳定匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%8C%B9%E9%85%8D"><span class="nav-number">1.1.</span> <span class="nav-text">定义(一对一匹配)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gale-Shapley-%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">Gale-Shapley 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GS%E7%AE%97%E6%B3%95-%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E"><span class="nav-number">1.3.</span> <span class="nav-text">GS算法 - 正确性证明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%B8%80%E5%AE%9A%E7%BB%88%E6%AD%A2"><span class="nav-number">1.3.1.</span> <span class="nav-text">算法一定终止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AE%8C%E7%BE%8E%E6%80%A7"><span class="nav-number">1.3.2.</span> <span class="nav-text">匹配的完美性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-number">1.3.3.</span> <span class="nav-text">匹配的稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.</span> <span class="nav-text">算法实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%96%B9%E5%88%A9%E7%9B%8A%E5%88%86%E6%9E%90"><span class="nav-number">1.5.</span> <span class="nav-text">主被动方利益分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E6%96%B9%E6%9C%80%E4%BC%98%E6%80%A7"><span class="nav-number">1.5.1.</span> <span class="nav-text">主动方最优性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A2%AB%E5%8A%A8%E6%96%B9%E6%9C%80%E5%8A%A3%E6%80%A7"><span class="nav-number">1.5.2.</span> <span class="nav-text">被动方最劣性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%8C%B9%E9%85%8D"><span class="nav-number">1.6.</span> <span class="nav-text">一对多匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95GS%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.</span> <span class="nav-text">扩展GS算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">Chapter 2 - 算法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90"><span class="nav-number">2.1.</span> <span class="nav-text">运行时间分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Asymptotic-Order-of-Growth"><span class="nav-number">2.2.</span> <span class="nav-text">Asymptotic Order of Growth</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.3.</span> <span class="nav-text">常见算法时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E9%9B%86%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.</span> <span class="nav-text">独立集问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%87%E6%91%8A%E5%88%86%E6%9E%90"><span class="nav-number">2.5.</span> <span class="nav-text">均摊分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-3-%E8%B4%AA%E5%BF%83"><span class="nav-number">3.</span> <span class="nav-text">Chapter 3 - 贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6"><span class="nav-number">3.1.</span> <span class="nav-text">区间调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E5%88%92%E5%88%86"><span class="nav-number">3.2.</span> <span class="nav-text">区间划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%96%E8%BF%9F%E5%88%B0"><span class="nav-number">3.3.</span> <span class="nav-text">最小化迟到</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra"><span class="nav-number">3.4.</span> <span class="nav-text">Dijkstra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-star"><span class="nav-number">3.5.</span> <span class="nav-text">$A^\star$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">3.6.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim"><span class="nav-number">3.6.1.</span> <span class="nav-text">Prim</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal"><span class="nav-number">3.6.2.</span> <span class="nav-text">Kruskal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reverse-Delete"><span class="nav-number">3.6.3.</span> <span class="nav-text">Reverse-Delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Boru%CC%8Avka"><span class="nav-number">3.6.4.</span> <span class="nav-text">Borůvka</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%B7%AF-K-%E8%81%9A%E7%B1%BB"><span class="nav-number">3.7.</span> <span class="nav-text">单链路 K-聚类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE"><span class="nav-number">3.8.</span> <span class="nav-text">最小树形图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95-Edmonds%E2%80%99-Algorithm"><span class="nav-number">3.8.1.</span> <span class="nav-text">朱刘算法 &#x2F; Edmonds’ Algorithm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E"><span class="nav-number">3.8.2.</span> <span class="nav-text">正确性证明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">3.9.</span> <span class="nav-text">哈夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">3.9.1.</span> <span class="nav-text">算法流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E8%AF%81%E6%98%8E"><span class="nav-number">3.9.2.</span> <span class="nav-text">相关证明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E7%BC%93%E5%AD%98"><span class="nav-number">3.10.</span> <span class="nav-text">最优缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-4-%E5%88%86%E6%B2%BB"><span class="nav-number">4.</span> <span class="nav-text">Chapter 4 - 分治</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E5%BA%8F%E5%AF%B9%E8%AE%A1%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">逆序对计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%B1%82%E7%AC%ACk%E5%B0%8F"><span class="nav-number">4.2.</span> <span class="nav-text">线性求第k小</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.1.</span> <span class="nav-text">随机化方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9"><span class="nav-number">4.3.</span> <span class="nav-text">平面最近点对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">整数乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">分块矩阵乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B7%E7%A7%AF%E4%B8%8EFFT"><span class="nav-number">4.6.</span> <span class="nav-text">卷积与FFT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="nav-number">4.6.1.</span> <span class="nav-text">多项式表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E6%95%B0%E8%BD%AC%E7%82%B9%E5%80%BC"><span class="nav-number">4.6.2.</span> <span class="nav-text">系数转点值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%82%B9%E5%80%BC%E8%BD%AC%E7%B3%BB%E6%95%B0"><span class="nav-number">4.6.3.</span> <span class="nav-text">点值转系数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">5.</span> <span class="nav-text">Chapter 5 - 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-6-%E9%9A%BE%E9%97%AE%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">Chapter 6 - 难问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%97%B6%E9%97%B4%E5%BD%92%E7%BA%A6"><span class="nav-number">6.1.</span> <span class="nav-text">多项式时间归约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%AD%89%E4%BB%B7%E5%BD%92%E7%BA%A6"><span class="nav-number">6.2.</span> <span class="nav-text">简单等价归约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%88%B0%E4%B8%80%E8%88%AC%E7%9A%84%E5%BD%92%E7%BA%A6"><span class="nav-number">6.3.</span> <span class="nav-text">特殊到一般的归约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8Gadgets%E7%9A%84%E5%BD%92%E7%BA%A6"><span class="nav-number">6.4.</span> <span class="nav-text">利用Gadgets的归约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E5%BD%92%E7%BA%A6"><span class="nav-number">6.5.</span> <span class="nav-text">三类问题的归约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P%E4%B8%8ENP"><span class="nav-number">6.6.</span> <span class="nav-text">P与NP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NP-Complete"><span class="nav-number">6.7.</span> <span class="nav-text">NP-Complete</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#P-NP-NPC"><span class="nav-number">6.7.1.</span> <span class="nav-text">P, NP, NPC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AF%81%E6%98%8ENPC"><span class="nav-number">6.7.2.</span> <span class="nav-text">如何证明NPC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BA%9BNPC%E9%97%AE%E9%A2%98%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">6.7.3.</span> <span class="nav-text">一些NPC问题的例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-7-%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="nav-number">7.</span> <span class="nav-text">Chapter 7 - 网络流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ford-Fulkerson%E7%AE%97%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">Ford-Fulkerson算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="nav-number">7.2.</span> <span class="nav-text">最大流与最小割</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E5%BC%95%E7%90%86"><span class="nav-number">7.2.1.</span> <span class="nav-text">流量引理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%B1%E5%AF%B9%E5%81%B6%E6%80%A7"><span class="nav-number">7.2.2.</span> <span class="nav-text">弱对偶性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E6%80%A7%E7%9A%84%E6%8E%A8%E8%AE%BA"><span class="nav-number">7.2.3.</span> <span class="nav-text">最优性的推论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Capacity-Scaling%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">Capacity-Scaling算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Edmonds-Karp-%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.</span> <span class="nav-text">Edmonds-Karp 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dinitz%E2%80%99s-%E7%AE%97%E6%B3%95"><span class="nav-number">7.5.</span> <span class="nav-text">Dinitz’s 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D"><span class="nav-number">7.6.</span> <span class="nav-text">二分图匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E7%9B%B8%E4%BA%A4%E8%B7%AF%E5%BE%84"><span class="nav-number">7.7.</span> <span class="nav-text">不相交路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%BA%90%E5%A4%9A%E6%B1%87"><span class="nav-number">7.8.</span> <span class="nav-text">多源多汇</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9B%E9%9C%80%E7%BD%91%E7%BB%9C"><span class="nav-number">7.9.</span> <span class="nav-text">供需网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%9F%A5%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.10.</span> <span class="nav-text">调查设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%88%AA%E7%8F%AD%E8%B0%83%E5%BA%A6"><span class="nav-number">7.11.</span> <span class="nav-text">航班调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2"><span class="nav-number">7.12.</span> <span class="nav-text">图像分割</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-8-%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="nav-number">8.</span> <span class="nav-text">Chapter 8 - 随机化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%B0%83%E5%BA%A6"><span class="nav-number">8.1.</span> <span class="nav-text">访问调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="nav-number">8.2.</span> <span class="nav-text">全局最小割</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A73-SAT"><span class="nav-number">8.3.</span> <span class="nav-text">最大3-SAT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E4%B8%8E%E6%8B%89%E6%96%AF%E7%BB%B4%E5%8A%A0%E6%96%AF"><span class="nav-number">8.4.</span> <span class="nav-text">蒙特卡洛与拉斯维加斯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">8.5.</span> <span class="nav-text">负载均衡</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Gu Tao"
      src="https://avatars.githubusercontent.com/u/109007949?v=4">
  <p class="site-author-name" itemprop="name">Gu Tao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gutaozi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gutaozi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gutao.official@gmail.com" title="E-Mail → mailto:gutao.official@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gutaozi.github.io/2026/01/11/CS216_Final_Review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/109007949?v=4">
      <meta itemprop="name" content="Gu Tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GuTao's Nest">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CS216 算法设计与分析 期末复习 | GuTao's Nest">
      <meta itemprop="description" content="原来算法学了这么多吗(＃°Д°)!">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS216 算法设计与分析 期末复习
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-01-11 16:44:53" itemprop="dateCreated datePublished" datetime="2026-01-11T16:44:53+08:00">2026-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">原来算法学了这么多吗(＃°Д°)!</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>$\huge\text{Outline}$</p>
<ol>
<li>稳定匹配</li>
<li>算法分析</li>
<li>贪心<ol>
<li>调度</li>
<li>Dijkstra</li>
<li>最小生成树</li>
<li>最小树形图</li>
<li>哈夫曼树</li>
<li>缓存</li>
</ol>
</li>
<li>分治<ol>
<li>$O(n\log n)$求逆序对</li>
<li>$O(n)$求第k小</li>
<li>$O(n\log n)$求平面最近点对</li>
<li>整数&#x2F;矩阵乘法</li>
<li>FFT与卷积</li>
</ol>
</li>
<li>动态规划<ol>
<li>带权区间调度</li>
<li>分段最小二乘</li>
<li>背包问题</li>
<li>区间DP</li>
<li>带负环图最短路</li>
</ol>
</li>
<li>难问题<ol>
<li>归约</li>
<li>P, NP, NPC</li>
</ol>
</li>
<li>网络流<ol>
<li>最大流与最小割</li>
<li>Ford-Fulkerson</li>
<li>Capacity-Scaling</li>
<li>Edmonds-Karp</li>
<li>Dinitz’s</li>
<li>二分图匹配</li>
<li>不相交路径</li>
<li>多源多汇网络流</li>
<li>调查设计</li>
<li>航班调度</li>
<li>图像分割</li>
</ol>
</li>
<li>随机化算法<ol>
<li>访问调度</li>
<li>全局最小割</li>
<li>最大3-SAT</li>
<li>负载均衡</li>
</ol>
</li>
</ol>
<hr>
<h2 id="Chapter-1-稳定匹配"><a href="#Chapter-1-稳定匹配" class="headerlink" title="Chapter 1 - 稳定匹配"></a>Chapter 1 - 稳定匹配</h2><h3 id="定义-一对一匹配"><a href="#定义-一对一匹配" class="headerlink" title="定义(一对一匹配)"></a>定义(一对一匹配)</h3><p>输入：两个集合 $A&#x3D;{a_1,\cdots,a_n}, B&#x3D;{b_1,\cdots,b_n}$，以及每个元素对另一集合所有元素的偏好表。</p>
<p>完美匹配：$f:A\rightarrow B$是双射</p>
<p>不稳定对：未出现在匹配中，且双方对对方的偏好程度均高于当前匹配的偏好程度。例如匹配中存在$(a_1,b_1),(a_2,b_2)$，但$a_1$相比$b_1$更偏好$b_2$，且$b_2$相比$a_2$更偏好$a_1$，那么$(a_1,b_2)$被称为不稳定对。</p>
<p>稳定匹配：不存在不稳定对的完美匹配</p>
<h3 id="Gale-Shapley-算法"><a href="#Gale-Shapley-算法" class="headerlink" title="Gale-Shapley 算法"></a>Gale-Shapley 算法</h3><p>保证可以找到一个稳定匹配的算法，此处以婚配为例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Initialize each person to be free.</span><br><span class="line">while (some man is free and hasn&#x27;t proposed to every woman)</span><br><span class="line">&#123;</span><br><span class="line">	Choose such a man m</span><br><span class="line">    w = 1st woman on m&#x27;s list to whom m has not yet proposed</span><br><span class="line">    if (w is free)</span><br><span class="line">    	assign m and w to be engaged</span><br><span class="line">    else if (w prefers m to her fiancé m&#x27;)</span><br><span class="line">    	assign m and w to be engaged, and m&#x27; to be free</span><br><span class="line">    else</span><br><span class="line">    	w rejects m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GS算法-正确性证明"><a href="#GS算法-正确性证明" class="headerlink" title="GS算法 - 正确性证明"></a>GS算法 - 正确性证明</h3><p><strong>Observation.</strong></p>
<ol>
<li>主动方按照偏好表降序提出匹配请求</li>
<li>被动方一旦匹配，就不会回到未匹配状态，只会更换到更偏好的匹配</li>
</ol>
<h4 id="算法一定终止"><a href="#算法一定终止" class="headerlink" title="算法一定终止"></a>算法一定终止</h4><p><strong>Claim</strong>. 算法在至多$n^2$轮while循环后终止</p>
<p><strong>Proof.</strong> 每次while循环，主动方会向一个新的被动方提出匹配请求，两个大小为$n$的集合至多有$n^2$种匹配，因此算法复杂度$O(n^2)$。</p>
<h4 id="匹配的完美性"><a href="#匹配的完美性" class="headerlink" title="匹配的完美性"></a>匹配的完美性</h4><p><strong>Claim.</strong> 所有元素在算法终止后都有匹配</p>
<p><strong>Proof.</strong> 反证法：假如某个主动方未被匹配，那么一定存在一个未被匹配的被动方。由Observation 2，该被动方一定从未收到匹配请求。但算法终止时主动方已对所有被动方进行了请求且仍未被匹配，引出矛盾。</p>
<h4 id="匹配的稳定性"><a href="#匹配的稳定性" class="headerlink" title="匹配的稳定性"></a>匹配的稳定性</h4><p><strong>Claim.</strong> 结果中不存在不稳定对</p>
<p><strong>Proof.</strong> 反证法：</p>
<p>记结果匹配为$S^\star$，其中存在配对$(a,y), (x,b)$。</p>
<p>假设存在不稳定对$(a,b)$，即$a$相比$y$更偏好$b$，而$b$相比$x$更偏好$a$</p>
<ol>
<li><p>$a$未向$b$发起匹配请求</p>
<p>说明$a$相比$b$更偏好$y$，引出矛盾</p>
</li>
<li><p>$a$向$b$发起过匹配请求</p>
<p>$b$拒绝了$a$，当即 或是 过了一会儿</p>
<p>说明$b$相比$a$更偏好$x$，引出矛盾</p>
</li>
</ol>
<p>两种情形均矛盾，因此不存在不稳定对。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>全局维护一个未匹配的主动方集合，每次选取其中的主动方进行匹配。</p>
<p>对于主动方，维护一个偏好值降序的队列，依次进行匹配请求。</p>
<p>对于被动方，维护一个从主动方到偏好值的映射，用于比对当前匹配是否更优，如有替换则将前任放回全局未匹配主动方集合。</p>
<h3 id="主被动方利益分析"><a href="#主被动方利益分析" class="headerlink" title="主被动方利益分析"></a>主被动方利益分析</h3><p>有效对象：如果某个稳定匹配中存在$(a,b)$，那么$a,b$互为有效对象。</p>
<h4 id="主动方最优性"><a href="#主动方最优性" class="headerlink" title="主动方最优性"></a>主动方最优性</h4><p><strong>Claim.</strong> GS算法得到的解$S^\star$对于主动方是最优的(每个主动方得到最优有效对象)</p>
<p><strong>Proof.</strong> 反证法：</p>
<p>假如不是主动方最优的，那么一定有某个主动方未与其最优有效对象匹配。</p>
<p>由于主动方是降序请求的，因此一定是被其最优有效对象拒绝了。</p>
<p>令首个这样的主动方为$a$，其最优有效对象为$b$。在$b$拒绝$a$时，一定更偏好于某个主动方$x$。由于$a$是首个被最优有效对象拒绝的主动方，所以$x$此时没有被任何有效对象拒绝过，即$b$是$x$的最优有效对象。</p>
<p>随后，由于$a$的最优有效对象是$b$，我们找到包含$(a,b)$的稳定匹配$S$，$S$包含$(x,y)$。根据上述分析，$b$相比$a$更偏好$x$，而$x$相比任何其他有效对象更偏好$b$，因此$(x,b)$是匹配$S$的不稳定对，引出矛盾。</p>
<h4 id="被动方最劣性"><a href="#被动方最劣性" class="headerlink" title="被动方最劣性"></a>被动方最劣性</h4><p><strong>Claim.</strong> GS算法得到的解$S^\star$对于被动方是最劣的(每个主动方得到最劣有效对象)</p>
<p><strong>Proof.</strong> 反证法：</p>
<p>假如不是被动方最劣的，那么一定有某个被动方未与其最劣有效对象匹配。</p>
<p>假如$S^\star$包含$(a,b)$，但$a$并不是$b$的最劣有效对象，假设其最劣有效对象为$x$。</p>
<p>我们找到包含$(x,b)$的稳定匹配$S$，$S$包含$(a,y)$。$b$相比$x$更偏好$a$，由主动方最优性，$b$一定是$a$的最优有效对象，即$a$相比$y$更偏好$b$，因此$(a,b)$是匹配$S$的不稳定对，引出矛盾。</p>
<h3 id="一对多匹配"><a href="#一对多匹配" class="headerlink" title="一对多匹配"></a>一对多匹配</h3><p>一对多匹配中，集合$A$中的一个元素可以与集合$B$中的多个元素匹配，此处将$A$中元素作为主动方进行讨论。</p>
<p>不稳定对$(a,b)$满足以下所有条件：</p>
<ul>
<li>$a,b$ 相互是可接受的</li>
<li>主动方$a$仍然有匹配容量，或者$a$相比其已经匹配的所有被动方元素更偏好$b$</li>
<li>被动方$b$未被匹配，或者$b$相比其已经匹配的主动方更偏好$a$</li>
</ul>
<h3 id="扩展GS算法"><a href="#扩展GS算法" class="headerlink" title="扩展GS算法"></a>扩展GS算法</h3><p>将具有容量的一方作为被动方，全局维护未匹配主动方的集合。</p>
<p>对于每个主动方，维护一个偏好值降序列表，依次进行匹配请求。</p>
<p>对于每个被动方，维护一个长度为容量的优先队列，存放当前被匹配的所有被动方。如果有更偏好的主动方请求匹配，将队首(偏好值最低)的主动方放回未匹配集合。</p>
<p>扩展GS算法的正确性和利益分析与上文所述类似，证明可参考Assignment 1。</p>
<h2 id="Chapter-2-算法分析"><a href="#Chapter-2-算法分析" class="headerlink" title="Chapter 2 - 算法分析"></a>Chapter 2 - 算法分析</h2><h3 id="运行时间分析"><a href="#运行时间分析" class="headerlink" title="运行时间分析"></a>运行时间分析</h3><p>最坏运行时间：给定输入数据规模，在所有不同的输入中，算法最大运行时间</p>
<p>平均运行时间：给定输入数据规模，对于随机的一个输入，算法的运行时间</p>
<p>最坏运行时间为多项式复杂度的算法被认为是高效的</p>
<h3 id="Asymptotic-Order-of-Growth"><a href="#Asymptotic-Order-of-Growth" class="headerlink" title="Asymptotic Order of Growth"></a>Asymptotic Order of Growth</h3><p><del>这玩意咋翻译来着，渐进时间复杂度吗</del></p>
<p>$O(n),\Omega(n),\Theta(n)$都是老朋友了</p>
<p>传递性，可加性，可乘性</p>
<h3 id="常见算法时间复杂度"><a href="#常见算法时间复杂度" class="headerlink" title="常见算法时间复杂度"></a>常见算法时间复杂度</h3><table>
<thead>
<tr>
<th>类型</th>
<th>时间复杂度</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>常数(Constant)</td>
<td>$O(1)$</td>
<td>打表</td>
</tr>
<tr>
<td>对数(Logarithmic)</td>
<td>$O(\log n)$</td>
<td>二分查找</td>
</tr>
<tr>
<td>线性(Linear)</td>
<td>$O(n)$</td>
<td>求极值</td>
</tr>
<tr>
<td>算术线性(?)(Linearithmic)</td>
<td>$O(n\log n)$</td>
<td>归并排序，堆排</td>
</tr>
<tr>
<td>平方(Quadratic)</td>
<td>$O(n^2)$</td>
<td>暴力最近点对</td>
</tr>
<tr>
<td>立方(Cubic)</td>
<td>$O(n^3)$</td>
<td>集合不相容</td>
</tr>
<tr>
<td>指数(Exponential)</td>
<td>$O(c^n)$</td>
<td>暴力最大独立集</td>
</tr>
</tbody></table>
<h3 id="独立集问题"><a href="#独立集问题" class="headerlink" title="独立集问题"></a>独立集问题</h3><p>区间调度：$O(n\log n)$贪心</p>
<p>带权区间调度：$O(n\log n)$动态规划</p>
<p>二分图匹配：$O(n^k)$基于最大流算法</p>
<p>最大独立集：NP-complete</p>
<p>竞争便利店选址问题：PSPACE-complete</p>
<h3 id="均摊分析"><a href="#均摊分析" class="headerlink" title="均摊分析"></a>均摊分析</h3><p>这是赵老师的Lab课件内容，不过内容还挺重要的，之后再补吧。</p>
<h2 id="Chapter-3-贪心"><a href="#Chapter-3-贪心" class="headerlink" title="Chapter 3 - 贪心"></a>Chapter 3 - 贪心</h2><h3 id="区间调度"><a href="#区间调度" class="headerlink" title="区间调度"></a>区间调度</h3><p>问题：工作用一系列区间表示，工作不可并行，每个工作等权，最大化截止时间前完成的工作数。</p>
<p>贪心算法：按照DDL升序排序，贪心地选择当前尚未错过开始时间且DDL最近的一个完成。</p>
<p><strong>Theorem.</strong> 贪心算法是最优的</p>
<p><strong>Proof.</strong> 反证法：假如贪心算法结果不是最优，令贪心结果为${i_n}$，最优结果为${j_m}$，且两种方案的前$r$项相同。我们在所有最优解中，找到一个${j_m}$使得其和贪心方案的重叠部分最多，即$r$最大。</p>
<p>由贪心策略，$i_{r+1}$的结束时间一定不会晚于$j_{r+1}$，那么我们将$i_{r+1}$替换${j_m}$方案中的$j_{r+1}$，依然会得到一个最优的可行解，但是此时的重叠部分长度为$r+1$，引出矛盾。</p>
<h3 id="区间划分"><a href="#区间划分" class="headerlink" title="区间划分"></a>区间划分</h3><p>问题：课程用一系列区间表示，课程不可在同一教室并行，求安排下所有课程所需的最小教室数量。</p>
<p>贪心算法：按照开课时间升序排列，申请的所有教室按照最后一堂课的结束时间</p>
<p>放进优先队列，对于每节课，看上节下课最早的教室能不能放下，能的话就放，如果放不下那就新开一个教室加入队列。</p>
<p><strong>Theorem.</strong> 贪心算法是最优的</p>
<p>记贪心算法申请的教室数为$d$</p>
<p>第$d$个教室是因为贪心算法在规划第$j$节课时，前$d-1$个教室都放不下了，即该$d-1$个教室的最后一堂课的下课时间都比$j$的上课时间晚。</p>
<p>由于贪心按上课时间升序排列课程，所以这$d-1$个教室中的课程开始时间都比$j$的开始时间要晚，因此在第$j$节课开课后有$d$节课在同时上课。</p>
<p>根据题意，要能支持$d$节课同时进行至少需要$d$个教室，即不存在比贪心解更优的解。</p>
<h3 id="最小化迟到"><a href="#最小化迟到" class="headerlink" title="最小化迟到"></a>最小化迟到</h3><p>问题：给定工作耗时和DDL，同时只能做一件事，迟到值设定为完成时间与DDL之间的差值，最小化最大的迟到值。</p>
<p>贪心算法：DDL越早越先做</p>
<p><strong>Observation.</strong> 存在没有任何空闲间隔的最优解，贪心解也没有任何空闲间隔</p>
<p><strong>Observation.</strong> 对于没有空闲间隔的解，如果存在两个任务，DDL早的后完成，DDL晚的先完成，则称为一个逆序对。如果一个解有逆序对，那一定有一对连续规划的逆序对。(why?)</p>
<p><strong>Claim.</strong> 交换逆序对不会使最大迟到值增加。</p>
<p><strong>Proof.</strong> 记交换前的迟到值为$l$，交换后为$l’$，工作完成时间为$f$，截止时间为$d$。</p>
<ul>
<li>对于$k\ne i,j$，$l_k’&#x3D;l_k$</li>
<li>$l_i’\le l_i$</li>
<li>$l_j’ &#x3D; \max{0,f_j-d_j} &#x3D; \max{0,f_i-d_j}\le \max{0,f_i-d_i} &#x3D; l_i$</li>
</ul>
<p>**Theorem. ** 贪心解$S$是最优的</p>
<p><strong>Proof.</strong> 令$S^\star$为一个没有空闲间隔且逆序对数量最少的最优解。</p>
<p>如果$S^\star$没有逆序对，那么$S&#x3D;S^\star$；</p>
<p>如果有逆序对，记相邻逆序对为$(i,j)$。交换$i,j$不会得到更劣解，但是将逆序对数量减少了1，引出矛盾。</p>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>这也是老朋友了，每次贪心地挑dis最小的一个点去更新其他所有点。</p>
<p><strong>Invariant.</strong> 对于每个已探索集合$S$中的点$u$，$d(u)$即为$s-u$最短路的长度。</p>
<p><strong>Proof.</strong> 归纳法：</p>
<p>基态：$|S|&#x3D;1$时，显然。</p>
<p>归纳假设：假设对于$|S|&#x3D;1,\cdots,k$的时候结论均成立</p>
<p>记下一个探索的点为$v$，选中的边是$(u,v)$，此时$s-v$路径的长度为$\pi (v) &#x3D; d(u)+l_{(u,v)}$。考虑任一$s-v$路径$P$，假设$(x,y)$是路径上离开$S$的第一条边，记到$x$的子路径为$P’$，那么有如下不等式：</p>
<p>$$l(P)\ge l(P’)+l_{(x,y)}\ge d(x)+l_{(x,y)}\ge \pi(y)\ge \pi(v)$$</p>
<p>从左到右四个不等号的原因分别为：边权非负，归纳假设，$\pi(y)$和$\pi(v)$的定义。由此证明了$d(v)&#x3D;\pi(v)$即为$s-v$最短路的长度，$|S|&#x3D;k+1$的时候也成立。</p>
<h3 id="A-star"><a href="#A-star" class="headerlink" title="$A^\star$"></a>$A^\star$</h3><p>给定起点和终点，引入启发式函数，用$h(v,t)+\pi(v)$作为优先级。</p>
<p>$h(v,t)&lt;d(v,t)$时保证结果正确，有可能比Dijkstra更快</p>
<p>$h(v,t)&#x3D;d(v,t)$时保证结果正确，最快，但需要完全正确的知识</p>
<p>$h(v,t)&gt;d(v,t)$时，并不总能得到正确结果，不过可能还是快一些</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><p>维护一个已选点的集合，迭代$n-1$次，每次将连接生成树和树外一点的最短边加入树，并且把树外断点加入集合。$O(m\log n)$</p>
<h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>将边按边权升序排列依次加入生成树，如果成环了就不加（并查集）。$O(m\log m)$</p>
<h4 id="Reverse-Delete"><a href="#Reverse-Delete" class="headerlink" title="Reverse-Delete"></a>Reverse-Delete</h4><p>按照边权降序排列边，如果删边不影响连通性就删，重复m次。$O(m\log n (\log\log n)^3)$</p>
<h4 id="Borůvka"><a href="#Borůvka" class="headerlink" title="Borůvka"></a>Borůvka</h4><p>对于每个连通块，选择所有一端在连通块内，另一端在外的边中边权最小的一个加入生成树，迭代直到只剩一个连通块收工。$O(m\log n)$</p>
<h3 id="单链路-K-聚类"><a href="#单链路-K-聚类" class="headerlink" title="单链路 K-聚类"></a>单链路 K-聚类</h3><p>问题：给定集合$U$，初始包含$n$个对象，将其分入$k$个非空集合，最大化不同集合之间距离的最小值。</p>
<p>贪心算法：用Kruskal算法，但是只加$n-k$条边。等价于找最小生成树，然后删掉最贵的$k-1$条边。</p>
<p><strong>Theorem.</strong> 贪心算法是最优的</p>
<p>待补。</p>
<h3 id="最小树形图"><a href="#最小树形图" class="headerlink" title="最小树形图"></a>最小树形图</h3><p>问题：给定有向图$G$和根节点$r$，边权非负，求根节点位于$r$的最小树形图。</p>
<p>对于每个非根节点$v$，$y(v)$表示进入$v$的所有边中最小的边权，边$(u,v)$削减后的边权记为$c’(u,v)&#x3D;c(u,v)-y(v)\ge 0$。</p>
<h4 id="朱刘算法-Edmonds’-Algorithm"><a href="#朱刘算法-Edmonds’-Algorithm" class="headerlink" title="朱刘算法 &#x2F; Edmonds’ Algorithm"></a>朱刘算法 &#x2F; Edmonds’ Algorithm</h4><p>对于每个非根节点$v$，选择最小入边，构成边集$E^\star$</p>
<p>$E^\star$中的所有边的削减后边权均为0，如果此时$E^\star$不包含环，则找到了最小树形图。</p>
<p>如果包含一个环$C$，那么将$C$收缩为一个超级结点，并删除其自环。</p>
<p>不断执行上述过程直到得到一个最小树形图，随后展开环删边断环即可。</p>
<h4 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h4><p>较为复杂，可参考课件，待补。</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>对于一个前缀编码格式$\gamma$，ABL (average bits per letter) 是每个字符的出现频率与其编码位数的乘积的和：</p>
<p>$$ABL(\gamma) &#x3D; \sum\limits_{x\in S}f_x|\gamma(x)|$$</p>
<p>哈夫曼编码：每次贪心选取出现频率最低的两个结点，将其连接到同一个父结点上，定义父节点的出现频率为两个子节点之和。伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Huffman(S)</span><br><span class="line">&#123;</span><br><span class="line">    if |S| == 2</span><br><span class="line">    &#123;</span><br><span class="line">    	return tree with root and 2 leaves</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        let x and y be lowest-frequency letters in S</span><br><span class="line">        let S’ be S with x and y removed</span><br><span class="line">        insert new letter ω in S’ with f[ω] = f[x] + f[y]</span><br><span class="line">        T’= Huffman(S’)</span><br><span class="line">        T = add two children x and y to leaf ω from T’</span><br><span class="line">        return T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相关证明"><a href="#相关证明" class="headerlink" title="相关证明"></a>相关证明</h4><p>时间复杂度：$T(n)&#x3D;T(n-1)+O(\log n)$，因此$T(n)&#x3D;O(n\log n)$。</p>
<p><strong>Claim.</strong> $ABL(T)&#x3D;ABL(T’)+f_w$</p>
<p><strong>Proof.</strong> $T$是由$T’$的$w$结点下接$x,y$结点形成的。</p>
<p>$$\begin{align*}ABL(T) &amp;&#x3D; \sum\limits_{k\in S}f_k\cdot \small\text{dep}<em>T(k)\&amp;&#x3D;f_x\cdot \small\text{dep}<em>T(x)+f_y\cdot \small\text{dep}<em>T(y)+\sum\limits</em>{k\in S&#x2F;{x,y}}f_k\cdot \small\text{dep}<em>T(k)\&amp;&#x3D;(f_y+f_z)\cdot (1+\small\text{dep}</em>{T’}(w))+\sum\limits</em>{k\in S&#x2F;{x,y}}f_k\cdot \small\text{dep}</em>{T’}(k)\&amp;&#x3D;f_w+f_w\cdot \small\text{dep}<em>{T’}(w)+\sum\limits</em>{k\in S&#x2F;{x,y}}f_k\cdot \small\text{dep}<em>{T’}(k)\&amp;&#x3D;f_w+\sum\limits</em>{k\in S’}f_k\cdot \small\text{dep}_{T’}(k)\&amp;&#x3D;f_w+ABL(T’)\end{align*}$$</p>
<p><strong>Observations.</strong></p>
<ul>
<li>在最优的前缀编码树中，出现频率最低的字符对应的结点应该出现在最底层</li>
<li>$n&gt;1$时，最低层总是有至少两个叶子节点</li>
<li>同一层中的顺序并不影响编码最优性</li>
</ul>
<p><strong>Claim.</strong> 存在最优的前缀编码树，使得出现频率最低的两个字符作为树的两个相邻的叶子节点。</p>
<p><strong>Claim.</strong> 对于给定字符集$S$，在所有前缀编码中，哈夫曼编码有最小的ABL。</p>
<p><strong>Proof.</strong> 归纳法：</p>
<p>基态：对于$|S|&#x3D;2$，没有比一根两叶更短的编码了</p>
<p>归纳假设：假设对于字符集$S’$，哈夫曼树$T’$给出的编码是最优的。其中$S’$没有加入最小频率的$x,y$而将$w$作为叶节点。</p>
<p>归纳步骤：反证法。</p>
<p>令$T$是哈夫曼树，假设存在树$Z$使得$ABL(Z)&lt;ABL(T)$，不失一般性地假设$Z$中$x, y$是相邻的叶子节点。将$x,y$从$Z$中删除得到$Z’$，记其父节点为$w’$。</p>
<p>由于$ABL(Z)&#x3D;ABL(Z’)+f_{w’}$，$ABL(T)&#x3D;ABL(T’)+f_w$，且$ABL(Z)&lt;ABL(T)$，$f_w&#x3D;f_{w’}$，得到$ABL(Z’)&lt;ABL(T’)$，与假设矛盾。</p>
<p>也可以参考<a target="_blank" rel="noopener" href="http://home.cse.ust.hk/faculty/golin/COMP271Sp03/Notes/MyL17.pdf">DSAA课程给的证明</a></p>
<h3 id="最优缓存"><a href="#最优缓存" class="headerlink" title="最优缓存"></a>最优缓存</h3><p>离线缓存 vs. 在线缓存：是否已知全部访问序列</p>
<p>贪心替换：LIFO, FIFO, LRU, LFU</p>
<p>最优贪心算法：Farthest-in-future (FF)，替换掉最晚在未来的访问中出现的成员。</p>
<p>最优性证明比较微妙，建议自己看课件过一遍。</p>
<h2 id="Chapter-4-分治"><a href="#Chapter-4-分治" class="headerlink" title="Chapter 4 - 分治"></a>Chapter 4 - 分治</h2><h3 id="逆序对计数"><a href="#逆序对计数" class="headerlink" title="逆序对计数"></a>逆序对计数</h3><p>$O(n\log n)$归并排序求逆序对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sort-and-Count(L)</span><br><span class="line">&#123;</span><br><span class="line">    if list L has one element</span><br><span class="line">    	return (0, L)</span><br><span class="line">    Divide the list into two halves A and B</span><br><span class="line">        (rA, A) = Sort-and-Count(A)</span><br><span class="line">        (rB, B) = Sort-and-Count(B)</span><br><span class="line">        (rAB, L) = Merge-and-Count(A, B)</span><br><span class="line">    return (rA + rB + rAB, L)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性求第k小"><a href="#线性求第k小" class="headerlink" title="线性求第k小"></a>线性求第k小</h3><p><del>这位更是印象深刻（✟Bo门✟</del></p>
<h4 id="随机化方法"><a href="#随机化方法" class="headerlink" title="随机化方法"></a>随机化方法</h4><p>随机选个主元(pivot)，将数组分为大于&#x2F;小于&#x2F;等于主元的三部分，数数第k大在哪一组，然后递归继续。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Quick-Select(A, k)</span><br><span class="line">&#123;	// 1 ≤ k ≤ |A|</span><br><span class="line">    Pick pivot p uniformly at random from A</span><br><span class="line">    Partition the list into two three parts L, M and R</span><br><span class="line">    if k ≤ |L|</span><br><span class="line">    	return Quick-Select(L, k)</span><br><span class="line">    else if k &gt; |L| + |M|</span><br><span class="line">    	return Quick-Select(R, k - |L| - |M|)</span><br><span class="line">    else</span><br><span class="line">    	return p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记$T(n,k)$为在长度为$n$的数组中求第$k$小的比较次数，记$T(n)&#x3D;\max_kT(n,k)$。</p>
<p><strong>Claim.</strong> $T(n)\le 4n$</p>
<p><strong>Proof.</strong> 强归纳：</p>
<p>$$\begin{align*}T(n)&amp;\le n + \frac{1}{n}[2T(n&#x2F;2)+\cdots+2T(n-2)+2T(n-1)]\&amp;\le n + \frac{1}{n}[8(n&#x2F;2)+\cdots+8(n-2)+8(n-1)]\&amp;\le n+\frac{1}{n}(3n^2)\&amp;&#x3D; 4n\end{align*}$$</p>
<p>确定性算法：中位数的中位数，优化版本大概要5.4305次比较，常数太大了实际一般不用，不过借鉴选主元的思路倒是不错。</p>
<h3 id="平面最近点对"><a href="#平面最近点对" class="headerlink" title="平面最近点对"></a>平面最近点对</h3><p>分治典中典。</p>
<p>问题：平面上$n$个点，找到点对间最小欧氏距离。</p>
<p>分治算法：按$x$坐标排序，分为数量相等的左右两部分。拆分：递归地分成两部分求子区域的最近点对距离；合并：左半边，右半边，以及左右两部分之间的点对距离。</p>
<p>记左右两部分内部的最近点对距离为$\delta$，合并时，只需要考虑横坐标在中点$±\delta$的点就足够了。对于中心区域的每个点$i$，我们也只需要考虑$y_i-\delta&lt;y_j\le y_i$的点$j$，因为每个点都要考虑所以只保证半边就行。为了方便比较$y$坐标，按$y$坐标再进行排序，这里排序可以用类似归并的方法，将低层递归排序后的点集归并即可，复杂度是$O(n)$的。</p>
<p>对于点$i$，记它需要比较的点集为$C_i$，$C_i$可能的分布范围是一个长为$2\delta$</p>
<p>宽为$\delta$的矩形，且$i$位于上长边的中点。将该矩形切分为8个${\delta\over2}*{\delta\over2}$的小正方形，那么每个小正方形内至多只能有一个点，除去$i$之后最多只有7个点。反证：每个小正方形内如果存在两个点，那么它们的距离最大值是$\delta\over\sqrt 2$，比之前设定的单边最小距离$\delta$还要小，引出矛盾。所以对于每个点$i$，我们只需要比对至多$7$个点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Closest-Pair(p1, ..., pn)</span><br><span class="line">&#123;</span><br><span class="line">    Compute vertical line L such that half the points</span><br><span class="line">    are on one side and half on the other side.</span><br><span class="line">    </span><br><span class="line">    δ1 = Closest-Pair(left half)</span><br><span class="line">    δ2 = Closest-Pair(right half)</span><br><span class="line">    δ = min(δ1, δ2)</span><br><span class="line">    </span><br><span class="line">    Delete all points further than δ from line L.</span><br><span class="line">    </span><br><span class="line">    Sort remaining points by y-coordinate.</span><br><span class="line">    </span><br><span class="line">    Scan points in y-order and compare distance between</span><br><span class="line">    each point and next 7 neighbors. If any of these</span><br><span class="line">    distances is less than δ, update δ.</span><br><span class="line">    </span><br><span class="line">    return δ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整数乘法"><a href="#整数乘法" class="headerlink" title="整数乘法"></a>整数乘法</h3><p>竖式乘法：$\Theta(n^2)$</p>
<p>基础分治乘法：$x\cdot y &#x3D;(2^ma+b)\cdot(2^mc+d) &#x3D; 2^{2m}ac+2^m(ad+bc)+bd$。$T(n)&#x3D;4T({n\over 2})+O(n)$，依然$\Theta(n^2)$</p>
<p>Karatsuba分治：$x\cdot y &#x3D; 2^{2m}ac+2^m(ac+bd-(a-b)(c-d))+bd$。$T(n)&#x3D;3T({n\over2})+O(n)$，降到了$\Theta(n^{\log_23})&#x3D;\Theta(n^{1.585})$</p>
<h3 id="分块矩阵乘法"><a href="#分块矩阵乘法" class="headerlink" title="分块矩阵乘法"></a>分块矩阵乘法</h3><p>$\begin{bmatrix}<br> C_{11} &amp; C_{12}\<br> C_{21} &amp; C_{22}<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br> A_{11} &amp; A_{12}\<br> A_{21} &amp; A_{22}<br>\end{bmatrix}\times\begin{bmatrix}<br> B_{11} &amp; B_{12}\<br> B_{21} &amp; B_{22}<br>\end{bmatrix}$</p>
<p>基础乘法：$C_{ij}&#x3D;(A_{i1}\times B_{1j})+(A_{i2}\times B_{2j})$。$T(n)&#x3D;4T({n\over2})+O(n^2)$，$T(n)&#x3D;O(n^3)$</p>
<p>Strassen分治：用7次矩阵乘法计算$P_1\sim P_7$，再用于计算$C_{ij}$。$T(n)&#x3D;7T({n\over 2})+O(n^2)$，$T(n)&#x3D;O(n^{2.81})$</p>
<h3 id="卷积与FFT"><a href="#卷积与FFT" class="headerlink" title="卷积与FFT"></a>卷积与FFT</h3><h4 id="多项式表示"><a href="#多项式表示" class="headerlink" title="多项式表示"></a>多项式表示</h4><p>系数表示：$A(x) &#x3D; \sum\limits_{i&#x3D;0}^{n-1}a_{i}x^{i}$，$B(x) &#x3D; \sum\limits_{i&#x3D;0}^{n-1}b_{i}x^{i}$</p>
<p>多项式乘法(线性卷积)：$A(x)\times B(x) &#x3D; \sum\limits_{i&#x3D;0}^{2n-2}c_ix^i$，其中$c_i&#x3D;\sum\limits_{j&#x3D;0}^{i}a_jb_{i-j}$。暴力$O(n^2)$</p>
<p>点值表示：$A(x)&#x3D;{(x_i,y_i)|i\in[0,n-1]}$，$B(x)&#x3D;{(x_i,z_i)|i\in[0,n-1]}$</p>
<p>多项式乘法：$A(x)\times B(x) &#x3D; {(x_i,y_i\times z_i)|i\in[0,2n-1]}$，$O(n)$但需要$2n$个点表示$A(x)$和$B(x)$</p>
<h4 id="系数转点值"><a href="#系数转点值" class="headerlink" title="系数转点值"></a>系数转点值</h4><p>对于$n-1$次多项式$A$，给定系数${a_i}$，输出多项式在$n$个点处的值。</p>
<p>我们选取$n$阶单位根$w^0,\cdots,w^{n-1}$，其中$w&#x3D;e^{2\pi i&#x2F;n}$，那么$(w^k)^n&#x3D;(e^{2\pi i&#x2F;n})^n&#x3D;(e^{\pi i})^{2k} &#x3D; 1$。并且有$n\over 2$阶单位根为$v^0,\cdots,v^{n&#x2F;2-1}$，其中$v&#x3D;w^2&#x3D;e^{4\pi i&#x2F;n}$。</p>
<p>将多项式拆成奇数次幂和偶数次幂两部分：</p>
<p>$$\begin{align}A_{even}(x)&amp;&#x3D;a_0+a_2x+a_4x^2+\cdots+a_{n&#x2F;2-2}x^{(n-1)&#x2F;2} \nonumber \A_{odd}(x)&amp;&#x3D;a_1+a_3x+a_5x^2+\cdots+a_{n&#x2F;2-1}x^{(n-1)&#x2F;2} \nonumber \end{align}$$</p>
<p>则有：</p>
<p>$$\begin{align}A(x)&amp;&#x3D;A_{even}(x^2)+xA_{odd}(x^2)\nonumber \A(-x)&amp;&#x3D;A_{even}(x^2)-xA_{odd}(x^2) \nonumber \end{align}$$</p>
<p>代入$n$阶单位根，有：</p>
<p>$$\begin{align*}A(w^k)&amp;&#x3D;A_{even}(v^k)+w^kA_{odd}(v^k),\ 0\le k&lt;n&#x2F;2\A(w^{k+n&#x2F;2})&amp;&#x3D;A_{even}(v^k)-w^kA_{odd}(v^k),\ 0\le k&lt;n&#x2F;2\end{align*}$$</p>
<p>那么我们就把求长度为$n$的多项式$A$在$w^k$和$w^{k+n&#x2F;2}$两处的点值的问题$O(1)$转移到了求$v^k$点处两个长度为$n\over 2$的多项式的点值。对于求$n$个单位根的问题，我们在$O(n)$时间将其拆分成了两个规模折半的问题，$T(n)&#x3D;2T(n&#x2F;2)+O(n)$，即$T(n)&#x3D;O(n\log n)$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FFT(n, a0, a1, …, an-1)</span><br><span class="line">&#123;</span><br><span class="line">    if (n == 1)</span><br><span class="line">    	return a0</span><br><span class="line">    </span><br><span class="line">    (e0,e1,…,en/2-1) = FFT(n/2, a0,a2,a4,…,an-2)</span><br><span class="line">    (d0,d1,…,dn/2-1) = FFT(n/2, a1,a3,a5,…,an-1)</span><br><span class="line">    </span><br><span class="line">    for k = 0 to n/2 - 1</span><br><span class="line">    &#123;</span><br><span class="line">        ω[k] = exp(2πik/n)</span><br><span class="line">        y[k] = ek + ω[k] dk</span><br><span class="line">        y[k+n/2] = ek - ω[k] dk</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="点值转系数"><a href="#点值转系数" class="headerlink" title="点值转系数"></a>点值转系数</h4><p>只需要将$w^{-1}$作为单位根的底数即可，同样是$O(n\log n)$的。</p>
<h2 id="Chapter-5-动态规划"><a href="#Chapter-5-动态规划" class="headerlink" title="Chapter 5 - 动态规划"></a>Chapter 5 - 动态规划</h2><p>这个就比较灵性，考课件原题也不难，考其他的推不出来就寄，待补。</p>
<h2 id="Chapter-6-难问题"><a href="#Chapter-6-难问题" class="headerlink" title="Chapter 6 - 难问题"></a>Chapter 6 - 难问题</h2><h3 id="多项式时间归约"><a href="#多项式时间归约" class="headerlink" title="多项式时间归约"></a>多项式时间归约</h3><p>如果问题$X$可以通过以下步骤解决，那么认为问题$X$可以多项式时间归约到问题$Y$：</p>
<ul>
<li>使用多项式数量的标准计算步骤</li>
<li>使用多项式数量的解决问题$Y$的算法</li>
</ul>
<p>问题$X$可以多项式时间归约到问题$Y$，记作$X\le_P Y$。</p>
<ul>
<li>如果$X\le_P Y$，且$Y$多项式可解，则$X$多项式可解</li>
<li>如果$X\le_P Y$，且$X$多项式不可解，则$Y$多项式不可解</li>
<li>如果$X\le_P Y$且$Y\le_P X$，记作$X\equiv_P Y$，$X$多项式可解当且仅当$Y$多项式可解</li>
</ul>
<h3 id="简单等价归约"><a href="#简单等价归约" class="headerlink" title="简单等价归约"></a>简单等价归约</h3><p>独立集问题：给定图$G$和整数$k$，是否存在大小至少为$k$的点集，使得其中的每个点互不相邻？</p>
<p>顶点覆盖问题：给定图和整数$k$，是否存在大小不超过$k$的点集，使得所有边至少和点集中的一个点相连？</p>
<p><strong>Claim.</strong> 独立集问题 $\equiv_P$ 顶点覆盖问题</p>
<p><strong>Proof.</strong> 证明$S$是一个独立集当且仅当$V-S$是一个顶点覆盖。</p>
<h3 id="特殊到一般的归约"><a href="#特殊到一般的归约" class="headerlink" title="特殊到一般的归约"></a>特殊到一般的归约</h3><p>集合覆盖问题：给定一个集合$U$，以及集合$U$的一系列子集的集合$S$，问是否能选出$S$中不超过$k$个成员，使得其并集等于$U$？</p>
<p><strong>Claim.</strong> 顶点覆盖问题 $\le_P$ 集合覆盖问题</p>
<p><strong>Proof.</strong> 对于任一顶点覆盖问题，将其边集$E$作为集合覆盖问题的全集$U$，对于每个顶点，记录与其相连的边的集合，所有顶点各自相连的边集作为$S$的成员，将顶点数量限制$k$作为集合数量限制$k$，这样就构造了一个集合覆盖问题。</p>
<h3 id="利用Gadgets的归约"><a href="#利用Gadgets的归约" class="headerlink" title="利用Gadgets的归约"></a>利用Gadgets的归约</h3><p>3-SAT：合取范式，每个子句由三个文字(分别对应一个变量)进行或运算得到，问可满足性。</p>
<p><strong>Claim.</strong> 3-SAT $\le_P$ 独立集问题</p>
<p><strong>Proof.</strong> 对于给定3-SAT问题，将每个变量映射到图上的两个顶点，表示$x_i$和$\overline x_i$并建边$(x_i,\overline x_i)$；对于每个子句，在其三个文字对应的变量对应的顶点间建边，得到图$G$。子句数量为$|\Phi|$，则令图$G$上所求独立集的大小设为$|\Phi|$。3-SAT有解当且仅当图$G$存在一个大小为$|\Phi|$的独立集。</p>
<p>由于独立集大小和子句数量一致，那么$G$中的每个三角都会有恰好一个点被选入独立集，将该点对应的变量设为真，就得到了一个3-SAT的解。</p>
<h3 id="三类问题的归约"><a href="#三类问题的归约" class="headerlink" title="三类问题的归约"></a>三类问题的归约</h3><p>决定问题：是否存在大小不超过$k$的顶点覆盖？</p>
<p>搜索问题：找到一个大小不超过$k$的顶点覆盖</p>
<p>优化问题：找到最小的顶点覆盖</p>
<p><strong>Theorem.</strong> 顶点覆盖问题 $\equiv_P$ 搜索顶点覆盖问题</p>
<p><strong>Proof.</strong> </p>
<p>$\le_P$：决定问题是搜索问题的特例，搜索问题有解说明决定问题为真</p>
<p>$\ge_P$：为了找到一个大小不超过$k$的顶点覆盖：</p>
<ul>
<li>确定是否存在大小不超过$k$的顶点覆盖</li>
<li>用$O(n)$时间找到点$v$，使得$G&#x2F;{v}$有一个大小不超过$k-1$的顶点覆盖</li>
<li>将$v$纳入顶点覆盖</li>
<li>在$G&#x2F;{v}$中递归寻找一个大小不超过$k-1$的顶点覆盖。</li>
</ul>
<p><strong>Theorem.</strong> 搜索顶点覆盖问题 $\equiv_P$ 最小顶点覆盖问题</p>
<p><strong>Proof.</strong></p>
<p>$\le_P$：搜索问题是优化问题的特例，优化问题解可作为搜索问题解</p>
<p>$\ge_P$：二分答案</p>
<h3 id="P与NP"><a href="#P与NP" class="headerlink" title="P与NP"></a>P与NP</h3><p>P：存在多项式时间算法的决定性问题的集合</p>
<p>NP：存在多项式时间校验器(certifier)的决定性问题的集合(非确定多项式时间)</p>
<p>校验器：并不直接说明问题是否有解，而是检验给定的证书(certificate)是否能说明原问题有解</p>
<p>证书：用于说明原问题可能有解的输入</p>
<p><strong>Claim.</strong> $P⊆NP$</p>
<p><strong>Proof.</strong> $\forall X\in P$，$\exists$多项式算法$A(s)$可解$X$，证书为空，校验器为$A(s)$</p>
<p>EXP：存在指数时间算法的决定性问题的集合</p>
<p><strong>Fact.</strong> $P\ne EXP ⇒ (P\ne NP)\vee(NP\ne EXP)$</p>
<h3 id="NP-Complete"><a href="#NP-Complete" class="headerlink" title="NP-Complete"></a>NP-Complete</h3><h4 id="P-NP-NPC"><a href="#P-NP-NPC" class="headerlink" title="P, NP, NPC"></a>P, NP, NPC</h4><p>如果问题$X$可以通过以下步骤解决，那么认为问题$X$可以多项式时间(Cook)归约到问题$Y$：</p>
<ul>
<li>使用多项式数量的标准计算步骤</li>
<li>使用多项式数量的解决问题$Y$的算法</li>
</ul>
<p>如果对于任意问题$X$的实例$x$，我们都能构造问题$y$的实例$Y$，使得$x$有解当且仅当$y$有解，则认为问题$X$可以多项式时间(Karp)转化到问题$Y$。</p>
<p>NP-Complete：满足对于任意$NP$问题$X$，都有$X\le_P Y$的$NP$问题$Y$的集合</p>
<p><strong>Theorem.</strong> $NP$完全问题$Y$满足$Y\in P$当且仅当$P&#x3D;NP$。</p>
<p><strong>Proof.</strong></p>
<ol>
<li>当$P&#x3D;NP$时，$Y\in P$因为$Y\in NP$。</li>
<li>假设$Y\in P$，对于任何$X\in NP$，由于$X\le_P Y$，得到$X\in P$，即$NP⊆P$，由于$P⊆NP$，得到$P&#x3D;NP$。</li>
</ol>
<p>NP-hard：每个$NP$问题都能多项式时间归约到的问题集合。</p>
<h4 id="如何证明NPC"><a href="#如何证明NPC" class="headerlink" title="如何证明NPC"></a>如何证明NPC</h4><p>电路可满足性问题：与或非门构成的组合电路，是否可以调整输入使输出为1？</p>
<p><strong>Theorem.</strong> 电路可满足性问题是$NP$完全问题</p>
<p><strong>Proof.</strong> </p>
<p>任何拥有定长输入，输出真&#x2F;假的确定性算法可以用这样的电路表示，如果算法是多项式时间的，电路也是多项式尺寸的。</p>
<p>考虑$\forall X\in NP$，以及多项式时间校验器$C(s,t)$，为确定$s\in X$是否成立，只需要知道是否有一个长度为$p(|s|)$的证书$t$使得校验器输出真。</p>
<p>将$C(s,t)$视作一个输入长度$|s|+p(|s|)$的算法，并且将其转换为多项式尺寸的电路$K$，前$s$位固定输入为$s$，后$p(|s|)$位输入证书$t$，电路$K$可满足当且仅当$C(s,t)$输出真。</p>
<p>证明问题$Y$是$NP$完全问题的方法：</p>
<ol>
<li>说明是$NP$问题</li>
<li>选一个$NP$完全问题$X$</li>
<li>证明$X\le_P Y$</li>
</ol>
<p><strong>Theorem.</strong> 3-SAT 是 $NP$完全问题</p>
<p><strong>Proof.</strong> 已知3-SAT$\in NP$，仅需证明电路可满足性问题$\le_P$3-SAT</p>
<p>对于任意电路$K$，对于每个电路元素$i$创建一个3-SAT变量$x_i$</p>
<p>对于与或非三种运算分别构建子句：</p>
<p>$$\begin{align*} x_2&amp;&#x3D;\neg x_3 &amp;⇒ &amp;x_2\vee x_3, \overline x_2\vee\overline x_3 \ x_1&amp;&#x3D;x_4\vee x_5 &amp;⇒ &amp;x_1\vee \overline x_4, x_1\vee\overline  x_5, x_1\vee x_4\vee x_5 \x_0&amp;&#x3D;x_1\wedge x_2 &amp;⇒ &amp;\overline x_0 \vee x_1, \overline x_0\vee x_2, x_0 \vee \overline x_1 \vee \overline x_2\end{align*}$$</p>
<p>随后将$K$硬编码的输入赋值给变量$x_i$，并将输出结点对应的变量$x_0$赋值为1。</p>
<p>最后，添加恒0变量来补全每个子句到三个文字，转化完成。</p>
<h4 id="一些NPC问题的例子"><a href="#一些NPC问题的例子" class="headerlink" title="一些NPC问题的例子"></a>一些NPC问题的例子</h4><p>集合覆盖，顶点覆盖，独立集，电路可满足性，SAT，3-SAT，哈密尔顿路径，哈密尔顿环路，TSP，三维匹配，三染色，子集和，背包</p>
<p>有很多$NP$问题要么是$P$要么是$NPC$，但也有反例： FACTOR, DISCRETE-LOG, GRAPH-ISOMORPHISM……</p>
<p><strong>Theorem.</strong> 除非$P&#x3D;NP$，不然就存在既不是$P$也不是$NPC$的$NP$问题。</p>
<h2 id="Chapter-7-网络流"><a href="#Chapter-7-网络流" class="headerlink" title="Chapter 7 - 网络流"></a>Chapter 7 - 网络流</h2><p>流量网络$G&#x3D;(V,E,s,t,c)$</p>
<p>流和割的定义：略</p>
<h3 id="Ford-Fulkerson算法"><a href="#Ford-Fulkerson算法" class="headerlink" title="Ford-Fulkerson算法"></a>Ford-Fulkerson算法</h3><p>正向边容量减去流量，反向边全权值设为流量</p>
<p>残量网络：边集为 有剩余容量的边 和 流量非零的反向边</p>
<p>增广路：残量网络中$s-t$的一条简单路径，处理后每条边容量都减去瓶颈容量，反向边都加上瓶颈容量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Augment(f, c, P)</span><br><span class="line">&#123;</span><br><span class="line">    b = bottleneck(P)</span><br><span class="line">    foreach e ∈ P</span><br><span class="line">    &#123;</span><br><span class="line">        if (e ∈ E) f(e) = f(e) + b</span><br><span class="line">        else f(eR) = f(eR) - b</span><br><span class="line">    &#125;</span><br><span class="line">    return f</span><br><span class="line">&#125;</span><br><span class="line">Ford-Fulkerson(G, s, t, c)</span><br><span class="line">&#123;</span><br><span class="line">    foreach e ∈ E: f(e) = 0</span><br><span class="line">    Gf = residual network of G with respect to flow f</span><br><span class="line">    </span><br><span class="line">    while (there exists an augmenting path P)</span><br><span class="line">    &#123;</span><br><span class="line">        f = Augment(f, c, P)</span><br><span class="line">        update Gf</span><br><span class="line">    &#125;</span><br><span class="line">    return f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度$O(mnC)$，因为每次增广至少提升一个流量，找到一个增广路需要$O(m)$时间。由于和容量相关，FF算法对于输入规模而言并不是多项式的。</p>
<p>输入规模：$m,n,\log C$，算法可能需要进行$2C$次迭代。</p>
<h3 id="最大流与最小割"><a href="#最大流与最小割" class="headerlink" title="最大流与最小割"></a>最大流与最小割</h3><h4 id="流量引理"><a href="#流量引理" class="headerlink" title="流量引理"></a>流量引理</h4><p>$f$是任意流，$(A,B)$是任意割，那么流的大小等于割之间的流的合成量</p>
<p>$$\begin{align*}v(f)&amp;&#x3D;\sum\limits_{e\ out\ of\ s}f(e)&#x3D;f^{out}(s)&#x3D;f^{out}(s)-f^{in}(s)\&amp;&#x3D;\sum\limits_{v\in A}(f^{out}(v)-f^{in}(v))\&amp;&#x3D;\sum\limits_{e\ out\ of\ A}f(e)-\sum\limits_{e\ into\ A}f(e)\&amp;&#x3D;f^{out}(A)-f^{in}(A)\end{align*}$$</p>
<h4 id="弱对偶性"><a href="#弱对偶性" class="headerlink" title="弱对偶性"></a>弱对偶性</h4><p>$f$是任意流，$(A,B)$是任意割，那么流的大小至多是割的容量</p>
<p>$$\begin{align*}v(f)&amp;&#x3D;f^{out}(A)-f^{in}(A)\&amp;\le f^{out}(A)\&amp;&#x3D;\sum\limits_{e\ out\ of\ A}f(e)\&amp;\le \sum\limits_{e\ out\ of\ A}c_e\&amp;&#x3D;c(A,B)\end{align*}$$</p>
<h4 id="最优性的推论"><a href="#最优性的推论" class="headerlink" title="最优性的推论"></a>最优性的推论</h4><p>$f$是任意流，$(A,B)$是任意割，如果$v(f)&#x3D;c(A,B)$，那么它们分别是最大流和最小割。</p>
<ol>
<li>存在一个割$(A,B)$使得$v(f)&#x3D;c(A,B)$</li>
<li>$f$是最大流</li>
<li>对于$f$，没有增广路</li>
</ol>
<p>1→2：弱对偶性的推论</p>
<p>2→3：逆否命题：如果对于$f$有增广路，那么可以增加$f$，所以$f$不是最大流</p>
<p>3→1：$f$没有增广路，$A$是残量网络中$s$可以到达的点的集合，因此$s\in A$而$t\notin A$</p>
<h3 id="Capacity-Scaling算法"><a href="#Capacity-Scaling算法" class="headerlink" title="Capacity-Scaling算法"></a>Capacity-Scaling算法</h3><p>设置一个阈值$\Delta$，初始值为$2^{\lfloor\log C\rfloor}$，每次只考虑瓶颈容量在$\Delta$以上的增广路，随后将$\Delta$折半直到为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Capacity-Scaling(G, s, t, c)</span><br><span class="line">&#123;</span><br><span class="line">    foreach e ∈ E: f(e) = 0</span><br><span class="line">    Δ = largest power of 2 ≤ C</span><br><span class="line">    Gf = residual network with respect to flow f</span><br><span class="line">    </span><br><span class="line">    while (Δ ≥ 1)</span><br><span class="line">    &#123;</span><br><span class="line">        Gf(Δ) = Δ-residual network of G with respect to flow f</span><br><span class="line">        while (there exists an augmenting path P in Gf(Δ))</span><br><span class="line">        &#123;</span><br><span class="line">            f = Augment(f, c, P)</span><br><span class="line">            update Gf(Δ)</span><br><span class="line">        &#125;</span><br><span class="line">        Δ = Δ / 2</span><br><span class="line">    &#125;</span><br><span class="line">    return f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lemma.</strong> 外层循环$1+\lfloor\log_2C\rfloor$次终止</p>
<p><strong>Lemma.</strong> $f$是每次$\Delta$缩减循环后的流，最大流的值不会超过$v(f)+m\Delta$</p>
<p><strong>Lemma.</strong> 每次缩减循环中，至多有$2m$条增广路</p>
<p>因此该算法时间复杂度$O(m^2\log C)$</p>
<h3 id="Edmonds-Karp-算法"><a href="#Edmonds-Karp-算法" class="headerlink" title="Edmonds-Karp 算法"></a>Edmonds-Karp 算法</h3><p>利用BFS找边数最少的增广路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Edmonds-Karp(G, s, t, c)</span><br><span class="line">&#123;</span><br><span class="line">    foreach e ∈ E: f(e) = 0</span><br><span class="line">    Gf = residual network of G with respect to flow f</span><br><span class="line">    </span><br><span class="line">    while (there exists an augmenting path P in Gf)</span><br><span class="line">    &#123;</span><br><span class="line">        P = Breath-First-Search(Gf)</span><br><span class="line">        f = Augment(f, c, P)</span><br><span class="line">        update Gf</span><br><span class="line">    &#125;</span><br><span class="line">    return f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lemma.</strong> 最短增广路的长度不会减少</p>
<p><strong>Lemma.</strong> 至多$m$次最短路增广后，最短增广路的长度严格上升</p>
<p>找最短增广路$O(m)$，至多有$n-1$种不同的长度，对每种长度至多增广$m$次。因此该算法时间复杂度$O(m^2n)$</p>
<h3 id="Dinitz’s-算法"><a href="#Dinitz’s-算法" class="headerlink" title="Dinitz’s 算法"></a>Dinitz’s 算法</h3><ul>
<li>建立分层图$L_G$</li>
<li>从$s$开始在$L_G$中搜索，直到卡住或者到达$t$</li>
<li>如果到达$t$，增广，更新分层图，从$s$再开始</li>
<li>如果卡住，那就从分层图中删除该结点，跳回到上个结点重来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Dinitz-Normal-Phase(Gf, s, t)</span><br><span class="line">&#123;</span><br><span class="line">    LG = level graph of Gf</span><br><span class="line">    P = empty path</span><br><span class="line">    Advance(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Advance(v)</span><br><span class="line">&#123;</span><br><span class="line">    if (v = t)</span><br><span class="line">        f = Augment(f, c, P)</span><br><span class="line">        remove bottleneck edges from LG</span><br><span class="line">        P = empty path</span><br><span class="line">        Advance(s)</span><br><span class="line">    if (there exists (v, w) ∈ LG)</span><br><span class="line">        add edge (v, w) to P</span><br><span class="line">        Advance(w)</span><br><span class="line">        Retreat(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retreat(v)</span><br><span class="line">&#123;</span><br><span class="line">    if (v = s) return</span><br><span class="line">    else</span><br><span class="line">        delete v and incident edges from LG</span><br><span class="line">        remove last edge (u, v) from P</span><br><span class="line">        Advance(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dinitz(G, s, t, c)</span><br><span class="line">&#123;</span><br><span class="line">    foreach e ∈ E: f(e) = 0</span><br><span class="line">    Gf = residual network of G with respect to flow f</span><br><span class="line">    </span><br><span class="line">    while (there exists an augmenting path P in Gf)</span><br><span class="line">    &#123;</span><br><span class="line">    	Dinitz-Normal-Phase(Gf, s, t)</span><br><span class="line">    &#125;</span><br><span class="line">    return f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个阶段初始化需要$O(m)$的BFS；增广至多$m$次，耗时$O(mn)$；回溯至多$n$次，耗时$O(m+n)$；至多$mn$次前进，耗时$O(mn)$。</p>
<p>每个阶段耗时$O(mn)$，至多有$n-1$个阶段，因此该算法时间复杂度$O(mn^2)$</p>
<h3 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h3><p>原图所有边容量设为$\infty$，将二分图的一方用容量为1的边全部连接到源点，另一方用容量为1的连到汇点得到图$G’$，$G’$的最大流就是最大匹配数。</p>
<p>赫尔婚姻定理：二分图$G$两点集$L,R$大小相同。$G$有完美匹配当且仅当对于所有$L$的子集$S$都有$|N(S)|\ge|S|$。</p>
<h3 id="不相交路径"><a href="#不相交路径" class="headerlink" title="不相交路径"></a>不相交路径</h3><p>两条不共用任何边的路径是不相交路径。</p>
<p>设置每条边容量为1，也就是最多只能被一条增广路通过，最大流就是不相交的路径数量，但并不一定是简单路径。</p>
<p>$s-t$割：每条$s-t$路径都用到了其中的至少一条边</p>
<p>Menger定理：最大的$s-t$不相交路径数等于最小$s-t$割所包含的边数。</p>
<p>如果是求无向图上的不相交路径数，那就每条无向边建两条有向边代替即可。</p>
<h3 id="多源多汇"><a href="#多源多汇" class="headerlink" title="多源多汇"></a>多源多汇</h3><p>把一个超级源点用$\infty$容量的边连到所有源点上，汇点同理。</p>
<h3 id="供需网络"><a href="#供需网络" class="headerlink" title="供需网络"></a>供需网络</h3><p>图$G$中，边有容量，点有需求&#x2F;产出，在circulation中为每条边赋流量，使得每个点的入流量与出流量的差值为需求&#x2F;产出。</p>
<p>在图$G’$中，把超级源点用产出值为容量的边连到所有产出的点上，需求点同理。图$G$有一个circulation当且仅当图$G’$最大流为所有需求的和。</p>
<p>图$G$不存在circulation，当且仅当图的一个点分割$(A,B)$中，$A$到$B$的容量和小于$B$中点的合需求量。</p>
<p>如果有下限要求，那一开始就把供方需求+2，接收方需求-2，再拆成两条边建，权值分别为(下限)和(上限与下限的差)</p>
<h3 id="调查设计"><a href="#调查设计" class="headerlink" title="调查设计"></a>调查设计</h3><p>从超级源点到受访者建边，容量上下限是受访者可以接受的问题数量；</p>
<p>从产品到超级汇点建边，容量上下限是产品调查结果的需求数量；</p>
<p>从受访者到产品建边，容量上限为1，同一个人对同一产品只能填写一次问卷；</p>
<p>从超级汇点到超级源点建边，容量无限制。所有点的供需均为0。</p>
<p>如果找到了integer circulation，说明有可行的调查方案</p>
<h3 id="航班调度"><a href="#航班调度" class="headerlink" title="航班调度"></a>航班调度</h3><p>每个航班拆成两个点，两点之间建立一个容量上下限均为1的边。</p>
<p>源点连接每个航班的入点，源点提供$c$组乘务人员，每个航班的出点用$[0,1]$的边连接汇点，需求$c$组乘务人员。从源点到汇点连接一条$[0,c]$的边，表示闲置乘务组。</p>
<p>如果航班可以首尾相连，将前一班的出点连接到后一班的入点，容量为$[0,1]$。</p>
<p>最小化所需乘务组数量时，可以二分$c$。航班数为$k$时，时间复杂度$O(k^3\log k)$。</p>
<h3 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h3><p>看看就好，现在也不用网络流做图像分割。</p>
<p>相邻格点间建双向边，容量为其一为前景另一为背景的罚值；</p>
<p>从源点到每个点建边，容量是该点和前景的相似度；</p>
<p>从每个点到汇点建边，容量是该点和背景的相似度。</p>
<p>在这个图上跑最小割就OK。</p>
<h2 id="Chapter-8-随机化"><a href="#Chapter-8-随机化" class="headerlink" title="Chapter 8 - 随机化"></a>Chapter 8 - 随机化</h2><p>随机化真的是一门具有极高美学价值的艺术。</p>
<h3 id="访问调度"><a href="#访问调度" class="headerlink" title="访问调度"></a>访问调度</h3><p>如果同时有多个进程请求访问资源，那就都不能访问资源。<del>两个和尚没水喝</del></p>
<p>$n$个进程，每个进程每个时刻有$1&#x2F;n$概率可以访问资源，那么不存在race condition的概率随$n$增加从$1&#x2F;2$收敛到$1&#x2F;e$。</p>
<p>所有进程都能在$2en\ln n$轮中完成访问的概率至少为$1-1&#x2F;n$。</p>
<h3 id="全局最小割"><a href="#全局最小割" class="headerlink" title="全局最小割"></a>全局最小割</h3><p>无向图，不给源点汇点，求全局的最小割。</p>
<p>网络流解法：选一些源点，对其他所有点$v$求最小$s-v$割</p>
<p>收缩算法：随便选一条边，收缩这条边并将两个端点合并为超级顶点，删掉自环保留其他边(包含重边)，重复该过程直到只剩两个超级结点，返回此时的割。</p>
<p><strong>Theorem</strong>. 收缩算法以不低于$2&#x2F;n^2$的概率给出最小割的正解</p>
<p>为了提高正确率，多跑几遍：当运行了$n^2\ln n$次时，还找不到正解的概率不超过$1&#x2F;n^2$。</p>
<p>实际上，全局最小割的随机算法可以达到$O(m\log^3 n)$，甚至比最大流算法还快。</p>
<h3 id="最大3-SAT"><a href="#最大3-SAT" class="headerlink" title="最大3-SAT"></a>最大3-SAT</h3><p><strong>Claim.</strong> 给定一个有$k$个子句的3-SAT问题，随机赋值可以满足的期望子句数是$7k&#x2F;8$。</p>
<p>由于是期望值，所以我们总是能通过随机生成一个满足高于$7k&#x2F;8$个子句的解。于是我们持续随机，直到找到一个满足不低于$7k&#x2F;8$个子句的解。</p>
<p>已被证明：除非$P&#x3D;NP$，否则没有比$7&#x2F;8-$渐进更高的随机渐进算法了。</p>
<h3 id="蒙特卡洛与拉斯维加斯"><a href="#蒙特卡洛与拉斯维加斯" class="headerlink" title="蒙特卡洛与拉斯维加斯"></a>蒙特卡洛与拉斯维加斯</h3><p>蒙特卡洛：能在多项式时间内跑完，但不一定给出正确结果</p>
<p>e.g. 全局最小割</p>
<p>拉斯维加斯：能保证给出正确结果，但不一定能在多项式时间内跑完</p>
<p>e.g. 随机快排，最大3-SAT算法</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>中心化控制：Round-Robin给每个处理器均衡安排任务</p>
<p>分布式控制：每个任务都以一定概率随机给任何处理器</p>
<p>问题：有多大概率某个处理器过载了？</p>
<p>利用切诺夫界和布尔边界等工具分析，没有处理器接受超过$\Theta(\log n&#x2F;\log \log n)$个任务的概率不低于$1-1&#x2F;n$。</p>
<img src="https://hliangzhao.cn/static/resources/mathbasis/markov.png" style="zoom: 67%;" />

<p>(切诺夫界示意图，从图片搜索引擎拿的，我也不知道对不对)</p>
<p>如果总任务数$m&#x3D;16n\ln n$，那么每个处理器的负载在一半到两倍平均值的概率不低于$1-2&#x2F;n$。</p>
<p><del>不知道处理器会不会过载，反正我写到这里已经过载了</del></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2026/01/11/CS215_Midterm_Review/" rel="prev" title="CS215 离散数学 半期复习">
                  <i class="fa fa-angle-left"></i> CS215 离散数学 半期复习
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2026/01/11/CS217_DSAA_final/" rel="next" title="CS217 数据结构与算法分析 期末复习">
                  CS217 数据结构与算法分析 期末复习 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">萌ICP备20269202号 </a>
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Gu Tao</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gutaozi.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"slideLeftBigIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="只用C语言实现的矩阵库，包含矩阵常用操作与运算，安全&amp;可拓展至上">
<meta property="og:type" content="article">
<meta property="og:title" content="CS205 C&#x2F;C++ Project03设计报告 C语言矩阵库">
<meta property="og:url" content="https://gutaozi.github.io/2022/11/05/CS205_%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A_Matrix_Library/index.html">
<meta property="og:site_name" content="咕桃w！">
<meta property="og:description" content="只用C语言实现的矩阵库，包含矩阵常用操作与运算，安全&amp;可拓展至上">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2022/10/29/ISBDZ7X1WxdnrPi.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/29/jgWrmOKsMZPNiHv.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/29/KC4NxfWbXqAr9HY.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/29/UW7Qe1SyVT62hBX.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/29/FNXEbCLoKOWUxgJ.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/qmQKaxO95sT14nC.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/eFrIh8cDbTSfOAQ.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/Vi9kB5tTDgGz1w8.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/z9MgQqcWDFhk2HT.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/rmu34DqKpo7nGB2.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/OBfg7usEH9AVkNi.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/RvWqULAaYg1tJQn.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/xsZzMyaATJX7BUF.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/r2tpMAf7mnSekV3.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/AMyiL6RSBpVwlnv.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/Jx2N4SXjBUD5lw8.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/30/hdIanKWlCuwJDom.png">
<meta property="article:published_time" content="2022-11-05T05:31:42.000Z">
<meta property="article:modified_time" content="2022-11-05T05:31:42.000Z">
<meta property="article:author" content="咕桃">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/10/29/ISBDZ7X1WxdnrPi.png">

<link rel="canonical" href="https://gutaozi.github.io/2022/11/05/CS205_%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A_Matrix_Library/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CS205 C/C++ Project03设计报告 C语言矩阵库 | 咕桃w！</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">咕桃w！</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gutaozi.github.io/2022/11/05/CS205_%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A_Matrix_Library/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/109007949?v=4">
      <meta itemprop="name" content="咕桃">
      <meta itemprop="description" content="Just Do It, But Not Just Do It.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咕桃w！">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS205 C/C++ Project03设计报告 C语言矩阵库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-05 13:31:42" itemprop="dateCreated datePublished" datetime="2022-11-05T13:31:42+08:00">2022-11-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          
            <div class="post-description">只用C语言实现的矩阵库，包含矩阵常用操作与运算，安全&可拓展至上</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Part-0-团队成员"><a href="#Part-0-团队成员" class="headerlink" title="Part 0. 团队成员"></a>Part 0. <del>团队</del>成员</h2><div class="table-container">
<table>
<thead>
<tr>
<th>姓名</th>
<th>学号</th>
<th><del>贡献率</del></th>
</tr>
</thead>
<tbody>
<tr>
<td>咕桃</td>
<td>-</td>
<td><del>100%</del></td>
</tr>
</tbody>
</table>
</div>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CS205_Project03</span><br><span class="line">│  CMakeLists.txt</span><br><span class="line">│  README.md</span><br><span class="line">│</span><br><span class="line">├─doc</span><br><span class="line">│  Report.pdf</span><br><span class="line">│</span><br><span class="line">├─inc</span><br><span class="line">│  MatrixC.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">   Benchmark.c</span><br><span class="line">   MatrixC.c</span><br></pre></td></tr></table></figure>
<h2 id="Part-1-Analysis"><a href="#Part-1-Analysis" class="headerlink" title="Part 1 - Analysis"></a>Part 1 - Analysis</h2><h3 id="题目重述-amp-主要思路"><a href="#题目重述-amp-主要思路" class="headerlink" title="题目重述&amp;主要思路"></a>题目重述&amp;主要思路</h3><p>本题目要求<strong>使用C语言</strong>实现一个矩阵操作库，利用结构体存储矩阵，支持<code>float</code>矩阵的函数和基本运算，并对便捷性、鲁棒性、安全性、可扩展性有较高要求。</p>
<p>根据题目描述，题目要求的矩阵运算库需要支持的主要功能为：</p>
<ol>
<li>仅使用C语言，使用CMake管理项目</li>
<li>结构体存储<code>float</code>类型矩阵</li>
<li>矩阵操作：创建、删除、复制</li>
<li>矩阵运算：矩阵加减乘，矩阵与标量四则运算，查询最值</li>
<li>矩阵函数(安全性、易用性&gt;效率)</li>
</ol>
<p>本项目除完成上述全部基础要求外，支持以下内容：</p>
<ol>
<li><strong>安全、用户友好</strong>：使用指针操作时的安全性检查，严格明确的报错和警告判定，精确、安全的内存申请与释放。</li>
<li><strong>创建函数</strong>：空矩阵、单位阵、对角阵、全赋值矩阵、随机矩阵、由数组创建矩阵、由字符串创建、由文件创建、由矩阵创建、提取子矩阵…较为丰富，可以覆盖相当程度的创建矩阵需求。</li>
<li><strong>矩阵操作</strong>：安全删除矩阵并释放内存、值复制/引用复制、交换矩阵、矩阵变形、矩阵按行/列拼接、元素修改…安全易用。</li>
<li><strong>矩阵查询</strong>：容量查询、自定义“最值”查询、单点查询、矩阵求秩、矩阵比较…安全易用易拓展。</li>
<li><strong>逐元素运算</strong>：对单个矩阵进行一元运算、对两个矩阵进行二元运算、对单个矩阵与标量进行二元运算。极易拓展，支持自定义运算函数或使用库内置函数。</li>
<li><strong>矩阵运算</strong>：矩阵加减乘、矩阵快速幂、求行列式…有两类实现：将结果存储于传入参数矩阵、将结果作为返回参数，前者节省内存，后者不影响传入矩阵。</li>
<li><strong>常用变换</strong>：矩阵上三角化、高斯消元法矩阵求逆、转置矩阵、截取矩阵…安全易用且对无法计算的情况有强鲁棒性。</li>
<li><strong>文件操作</strong>：从文件创建矩阵、输出结果到文件</li>
<li><strong>项目管理</strong>：使用CMake和GitHub管理项目。</li>
</ol>
<h3 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h3><p>项目要求关于应用场景仅给出了数据类型为<code>float</code>的要求，笔者考虑理工科计算所可能使用的数据范围作为本项目支持的数据规模，如下：</p>
<ul>
<li><p>单个元素均为4字节<code>float</code>类型，有效位数默认为6位，数据范围约$-3.4 \cdot 10^{-38}&lt;val&lt;3.4 \cdot 10^{38}$</p>
</li>
<li><p>矩阵行数$row$与列数$col$之积，即矩阵容量满足$size=row*col\leq10^8$</p>
</li>
<li><p>项目对安全性要求&gt;计算效率，因此尽可能使用浅显稳定的算法，细节处有对效率的提升。</p>
</li>
</ul>
<h2 id="Part-2-Code"><a href="#Part-2-Code" class="headerlink" title="Part 2 - Code"></a>Part 2 - Code</h2><h3 id="宏与结构体"><a href="#宏与结构体" class="headerlink" title="宏与结构体"></a>宏与结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE float</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> float_equal(x, y) ((x-y)&lt;1e-5&amp;&amp;(y-x)&lt;1e-5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_MAX_CAPACITY 100000000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MatrixC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> row;</span><br><span class="line">    <span class="type">size_t</span> col;</span><br><span class="line">    TYPE *data;</span><br><span class="line">&#125; Matrix;</span><br></pre></td></tr></table></figure>
<p>本项目中，所有涉及矩阵元素下标的迭代变量均使用标准库常用的<code>size_t</code>类型，提高库在不同平台间的可移植性。</p>
<p>项目默认类型为<code>float</code>，笔者挺想做成类模板一样的可拓展形式，但由于C结构体不能像C++类一样使用模板，因而此处以宏进行丐版替代，有需求时可以调整<code>TYPE</code>，并对一些运算细节做微调就能适用不同数据类型。</p>
<p>经课程提醒，<code>float</code>类型的精度损失常导致<code>==</code>不能按预期判断相等，因此以宏的形式实现了浮点判等，误差在$10^{-5}$以内的数判断为相等。</p>
<p>矩阵容量上限为$10^8$个浮点元素，满足大部分情景的需求。</p>
<p>矩阵元素均存储于浮点指针<code>data</code>所指向的“一维浮点数组”中，data的容量由创建时赋为$row*col$后不作改变，更改方式仅有释放内存后重定向指针，从而避免了正常使用下段错误的发生。</p>
<hr>
<p><strong>在<a target="_blank" rel="noopener" href="https://github.com/GuTaoZi/CS205_Project03/blob/master/inc/MatrixC.h">MatrixC.h</a>头文件中，记录了本项目实现的矩阵相关的函数，经整理分为以下若干类：</strong></p>
<h3 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Functions For Creating Matrices</span></span><br><span class="line">Matrix *<span class="title function_">create_empty</span><span class="params">(<span class="type">size_t</span> row, <span class="type">size_t</span> col)</span>;<span class="comment">//空矩阵</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">create_full</span><span class="params">(<span class="type">size_t</span> row, <span class="type">size_t</span> col, TYPE value)</span>;<span class="comment">//全部赋相同值</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">create_from_array</span><span class="params">(TYPE *src, <span class="type">size_t</span> row, <span class="type">size_t</span> col)</span>;<span class="comment">//由数组赋值</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">create_from_string</span><span class="params">(<span class="type">char</span> *src, <span class="type">size_t</span> row, <span class="type">size_t</span> col)</span>;<span class="comment">//由字符串赋值</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">create_from_file</span><span class="params">(<span class="type">char</span> *f_path, <span class="type">size_t</span> row, <span class="type">size_t</span> col)</span>;<span class="comment">//由文件赋值</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">create_copy</span><span class="params">(Matrix *src)</span>;<span class="comment">//创建浅拷贝</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">create_identity</span><span class="params">(<span class="type">size_t</span> order)</span>;<span class="comment">//单位阵</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">create_diagonal</span><span class="params">(TYPE *src, <span class="type">size_t</span> order)</span>;<span class="comment">//传入数组→对角阵</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">create_random</span><span class="params">(<span class="type">size_t</span> row, <span class="type">size_t</span> col)</span>;<span class="comment">//随机阵</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">sub_matrix</span><span class="params">(Matrix *src, <span class="type">size_t</span> row_begin, <span class="type">size_t</span> col_begin, <span class="type">size_t</span> row_end, <span class="type">size_t</span> col_end)</span>;<span class="comment">//子矩阵截取</span></span><br></pre></td></tr></table></figure>
<p>命名一目了然，简洁易懂，功能齐全，此处以创建空矩阵为例浅谈安全的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Matrix *<span class="title function_">create_empty</span><span class="params">(<span class="type">size_t</span> row, <span class="type">size_t</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (row * col == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;Illegal matrix size&quot;</span>, <span class="string">&quot;Row and Col should be positive integers.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (row * col &gt; MATRIX_MAX_CAPACITY)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;Illegal matrix size&quot;</span>, <span class="string">&quot;The maximum size of matrix is row*col=1e8.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Matrix));</span><br><span class="line">    new-&gt;row = row;</span><br><span class="line">    new-&gt;col = col;</span><br><span class="line">    new-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TYPE) * row * col);</span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>传入参数为两个<code>size_t</code>类型变量(unsigned)，首先检查尺寸的合法性：$0&lt;row*col\leq10^8$，不对就报错返空(返回的<code>NULL</code>指针在后续的使用中也会严格检查)</li>
<li>使用<code>malloc</code>为新矩阵指针<code>new</code>分配一个<code>Matrix</code>类型的内存，其中包含结构体的两个<code>size_t</code>类型变量，即刻为其赋值。</li>
<li>对分配的一个<code>float *</code>浮点数指针变量申请$row*col$大小的内存。</li>
<li>返回矩阵指针，创建完毕。</li>
</ol>
<p>其他矩阵的创建均有调用该函数，实现简单，并检查了返回<code>NULL</code>等情况，此处不做赘述。</p>
<hr>
<h3 id="矩阵级别操作"><a href="#矩阵级别操作" class="headerlink" title="矩阵级别操作"></a>矩阵级别操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Functions For Matrix Operations</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_matrix</span><span class="params">(Matrix **pmat)</span>;<span class="comment">//安全删除</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">reshape_matrix</span><span class="params">(Matrix *src, <span class="type">size_t</span> row, <span class="type">size_t</span> col)</span>;<span class="comment">//不变尺寸的矩阵变形</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">copy_matrix</span><span class="params">(Matrix *dest, Matrix *src)</span>;<span class="comment">//值复制</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ref_matrix</span><span class="params">(Matrix *dest, Matrix *src)</span>;<span class="comment">//引用复制</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">swap_matrix</span><span class="params">(Matrix *first, Matrix *second)</span>;<span class="comment">//交换矩阵</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">col_concat</span><span class="params">(Matrix *first, Matrix *second)</span>;<span class="comment">//按列拼接</span></span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">row_concat</span><span class="params">(Matrix *first, Matrix *second)</span>;<span class="comment">//按行拼接</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">set_value</span><span class="params">(Matrix *pmat, <span class="type">size_t</span> row, <span class="type">size_t</span> col, TYPE value)</span>;<span class="comment">//单点修改</span></span><br></pre></td></tr></table></figure>
<p>上述函数分别为：删除、变形、浅拷贝、深拷贝、交换、按列拼接、按行拼接。</p>
<p>原本前五个是无返回函数，笔者觉得返回值不能就这么浪费了，因此传回布尔型，代表该操作是否成功进行(若发生异常会输出报错/警告信息，并返回false)。</p>
<p>以下是部分函数的展开讲解（其他的实现原理简单且类似，故不做赘述）：</p>
<h3 id="删除矩阵"><a href="#删除矩阵" class="headerlink" title="删除矩阵"></a>删除矩阵</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">delete_matrix</span><span class="params">(Matrix **pmat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pmat == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The address of the pointer to the matrix is null, delete process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pmat) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>, <span class="string">&quot;The pointer to the matrix is null, delete process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>((*pmat)-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(*pmat);</span><br><span class="line">    *pmat = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵的删除函数步骤如下：</p>
<ol>
<li>判断空指针并报错</li>
<li>释放结构体内浮点指针所指内存</li>
<li>释放结构体内存</li>
<li>置空指针</li>
</ol>
<p>本项目将指针指针(指针的地址)作为传入参数，这是由于C在处理空指针时有良好的鲁棒性(如<code>free(NULL)</code>将不进行操作)，在释放结构体内存后将指向结构体的<strong>指针本身置空</strong>，可以避免<strong>对野指针进行操作</strong>的高危行为。</p>
<p>然而将指针本身作为传入参数进行值传递后，在函数内将传入参数置空并不耽误原指针还是野指针，C也没有引用，故传入指针的指针对原指针进行置空。</p>
<p>值得一提，虽然C对于“释放空指针的内存”有所提防，但本函数依然对传入指针为空的情况做了报错，让用户清楚地知道可能进行了<strong>释放空指针所指内存</strong>这样的行为。</p>
<h3 id="复制矩阵"><a href="#复制矩阵" class="headerlink" title="复制矩阵"></a>复制矩阵</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">copy_matrix</span><span class="params">(Matrix **dest, Matrix *src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The pointer to source matrix is null, copy process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*dest == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dest = create_copy(src);</span><br><span class="line">        <span class="keyword">if</span> (*dest == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        print_warning(<span class="string">&quot;Copy into null matrix&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;The pointer to destination matrix is null, the pointer will point to a copy matrix of source matrix.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (((*dest)-&gt;row != src-&gt;row) || ((*dest)-&gt;col != src-&gt;col))</span><br><span class="line">        &#123;</span><br><span class="line">            print_warning(<span class="string">&quot;Copy into matrix of different sizes&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;The sizes of two matrices are different, the data of destination matrix will be covered by source matrix.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        delete_matrix(dest);</span><br><span class="line">        *dest = create_copy(src);</span><br><span class="line">        <span class="keyword">if</span> (*dest == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ref_matrix</span><span class="params">(Matrix **dest, Matrix *src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The pointer to source matrix is null, copy process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*dest!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delete_matrix(dest);</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = src;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种复制的实现都很简洁安全：若目标矩阵为空则会为其申请空间并复制，若目标矩阵与源矩阵尺寸不同会警告用户复制将覆盖目标矩阵原有信息，且对可能出现的错误进行报错处理。</p>
<h3 id="拼接矩阵"><a href="#拼接矩阵" class="headerlink" title="拼接矩阵"></a>拼接矩阵</h3><p>由于高斯消元求逆过程用到了按行拼接，此处对其进行简单讲解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Matrix *<span class="title function_">row_concat</span><span class="params">(Matrix *first, Matrix *second)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span> || second == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>, <span class="string">&quot;The pointer to source matrix is null, concat process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first-&gt;row != second-&gt;row)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;Illegal matrix shape&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The number of row of source matrices should be the same, concat process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *new = create_empty(first-&gt;row, first-&gt;col + second-&gt;col);</span><br><span class="line">    <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; first-&gt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; first-&gt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new-&gt;data[i * new-&gt;col + j] = first-&gt;data[i * first-&gt;col + j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; second-&gt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new-&gt;data[i * new-&gt;col + j + first-&gt;col] = second-&gt;data[i * second-&gt;col + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按行拼接的步骤如下：</p>
<ol>
<li>检查空指针，检查两个矩阵行数是否相等并报错</li>
<li>新建合并大小的空矩阵指针<code>new</code>，检查大小是否在合法范围内</li>
<li>逐行将两个矩阵的值传入<code>new</code></li>
<li>返回<code>new</code></li>
</ol>
<p>拼接原理即按行赋值，左边<code>first</code>，右边<code>second</code>。容易忽视的漏洞是拼接前两个大小合适的矩阵可能在拼接后超限，此时不应对空指针<code>new</code>进行赋值，而应报错。</p>
<hr>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Functions For Querying In Matrices</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">size_of</span><span class="params">(Matrix *pmat)</span>;<span class="comment">//查询容量</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">rank</span><span class="params">(Matrix *pmat)</span>;<span class="comment">//矩阵求秩</span></span><br><span class="line"></span><br><span class="line">TYPE <span class="title function_">get_value</span><span class="params">(Matrix *src, <span class="type">size_t</span> row, <span class="type">size_t</span> col)</span>;<span class="comment">//单点查询</span></span><br><span class="line"></span><br><span class="line">TYPE <span class="title function_">max</span><span class="params">(Matrix *src)</span>;<span class="comment">//矩阵最大值</span></span><br><span class="line"></span><br><span class="line">TYPE <span class="title function_">min</span><span class="params">(Matrix *src)</span>;<span class="comment">//矩阵最小值</span></span><br><span class="line"></span><br><span class="line">TYPE <span class="title function_">extreme_value</span><span class="params">(Matrix *src, <span class="type">bool</span> (*fun)(TYPE, TYPE))</span>;<span class="comment">//矩阵自定义“最值”</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">equal</span><span class="params">(Matrix *first, Matrix *second)</span>;<span class="comment">//矩阵判等</span></span><br></pre></td></tr></table></figure>
<p>矩阵求秩主要依靠上三角化实现，矩阵的秩即上三角化后非零行的数量，详见下文上三角化函数。</p>
<h3 id="自定义最值"><a href="#自定义最值" class="headerlink" title="自定义最值"></a>自定义最值</h3><p>求最值的思路是遍历<code>data</code>数组并逐个比较，方法朴素但安全，易于维护，下面简述可扩展的<code>extreme_value</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TYPE <span class="title function_">extreme_value</span><span class="params">(Matrix *src, <span class="type">bool</span> (*cmp)(TYPE, TYPE))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The pointer to source matrix is null, return NaN.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> nanf(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TYPE ans = src-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; size_of(src); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(src-&gt;data[i], ans))</span><br><span class="line">        &#123;</span><br><span class="line">            ans = src-&gt;data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵自定义最值的步骤如下：</p>
<ol>
<li>判断空指针并报错，返回<code>NaN</code></li>
<li>根据<code>cmp</code>函数逐个比较矩阵元素</li>
<li>返回答案</li>
</ol>
<p>此处将函数指针作为第三参数传入，实现了“比较”过程的自定义可拓展，对于<code>TYPE</code>类型的数据，比较规则可以通过自定义<code>cmp</code>函数进行调整，灵感来自于<code>sort</code>的自定义比较函数。</p>
<hr>
<h3 id="自定义矩阵运算"><a href="#自定义矩阵运算" class="headerlink" title="自定义矩阵运算"></a>自定义矩阵运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Functions For Customized Calculation</span></span><br><span class="line">TYPE <span class="title function_">plus</span><span class="params">(TYPE first, TYPE second)</span>;</span><br><span class="line"></span><br><span class="line">TYPE <span class="title function_">minus</span><span class="params">(TYPE first, TYPE second)</span>;</span><br><span class="line"></span><br><span class="line">TYPE <span class="title function_">mul</span><span class="params">(TYPE first, TYPE second)</span>;</span><br><span class="line"></span><br><span class="line">TYPE <span class="title function_">divide</span><span class="params">(TYPE first, TYPE second)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Functions For Matrix Calculation</span></span><br><span class="line">Matrix *<span class="title function_">unary_calc</span><span class="params">(Matrix *pmat, TYPE(*fun)(TYPE))</span>;</span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">binary_calc</span><span class="params">(Matrix *first, Matrix *second, TYPE (*fun)(TYPE, TYPE))</span>;</span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">scalar_calc</span><span class="params">(Matrix *pmat, TYPE scalar, TYPE(*fun)(TYPE, TYPE))</span>;</span><br></pre></td></tr></table></figure>
<p>考虑到我们经常要对矩阵进行逐元素的运算，例如矩阵统一求相反数是逐元素一元运算，矩阵加减法是逐元素二元运算…为了减轻用户为了不同的运算而自行实现多个函数的压力，本项目将<strong>一元、二元、矩阵与标量的运算</strong>整合为<strong>拓展性极强的函数</strong>，用户只需要自定义好运算函数，传入即可对矩阵进行<strong>逐元素的自定义运算</strong>。例如用户要对矩阵中的每个元素求正弦，那么只需要传入<code>Math.h</code>内置的<code>sinf(float x)</code>即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *sin_matrix = unary_calc(Matrix *pmat, sinf);</span><br></pre></td></tr></table></figure>
<p>代码部分选择二元运算进行展示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Matrix *<span class="title function_">binary_calc</span><span class="params">(Matrix *first, Matrix *second, TYPE (*fun)(TYPE, TYPE))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>, <span class="string">&quot;The pointer to the first matrix is null, calculation interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (second == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>, <span class="string">&quot;The pointer to the second matrix is null, calculation interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first-&gt;row != second-&gt;row || first-&gt;col != second-&gt;col)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;Illegal matrix shape&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The shape of two matrices are different, calculation process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *new = create_copy(first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size_of(new); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        new-&gt;data[i] = fun(new-&gt;data[i], second-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤也很简单，检查报错→申请空间→代入运算→存入结果，简洁高效易懂。</p>
<p>也因此，题目要求的四种标量运算只用向<code>scalar_calc</code>传入<code>plus</code>, <code>minus</code>, <code>mul</code>, <code>divide</code>四个自定义函数即可。</p>
<hr>
<h3 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Functions For Matrix Calculation</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">add_by</span><span class="params">(Matrix *augend, Matrix *addend)</span>;</span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">matrix_add</span><span class="params">(Matrix *augend, Matrix *addend)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">subtract_by</span><span class="params">(Matrix *minuend, Matrix *subtrahend)</span>;</span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">matrix_subtract</span><span class="params">(Matrix *minuend, Matrix *subtrahend)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">multiply_by</span><span class="params">(Matrix **multiplicand, Matrix *multiplier)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">multiply_to</span><span class="params">(Matrix *multiplicand, Matrix **multiplier)</span>;</span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">matrix_multiply</span><span class="params">(Matrix *multiplicand, Matrix *multiplier)</span>;</span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">matrix_pow</span><span class="params">(Matrix *base, <span class="type">int</span> power)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">add_scalar</span><span class="params">(Matrix *pmat, TYPE scalar)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">subtract_scalar</span><span class="params">(Matrix *pmat, TYPE scalar)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">multiply_scalar</span><span class="params">(Matrix *pmat, TYPE scalar)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">divide_scalar</span><span class="params">(Matrix *pmat, TYPE scalar)</span>;</span><br></pre></td></tr></table></figure>
<p>矩阵运算的实际应用场景中经常会有类似<strong>自增</strong>的需求(将结果保存在两个矩阵中的其中一个)，尤其体现在矩阵的<strong>左乘和右乘</strong>等方面。</p>
<p>本项目除了实现将结果作为新结构体返回的函数，也实现了将结果存入两个矩阵之一的函数，返回值为布尔型的函数会将结果存入传入的矩阵中。布尔型的返回值代表操作是否成功，若失败则返回<code>false</code>并报错，不对传入矩阵做任何操作。</p>
<p>以下是矩阵乘法的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Matrix *<span class="title function_">matrix_multiply</span><span class="params">(Matrix *multiplicand, Matrix *multiplier)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (multiplicand == <span class="literal">NULL</span> || multiplier == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The pointers to multiplicand and multiplier matrix are null, multiplication process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (multiplicand-&gt;col != multiplier-&gt;row)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;Illegal matrix shape&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The col number of multiplicand matrix should equal to row number of multiplier matrix.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *new = create_full(multiplicand-&gt;row, multiplier-&gt;col, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= multiplicand-&gt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">1</span>; k &lt;= multiplicand-&gt;col; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            TYPE t = multiplicand-&gt;data[(i - <span class="number">1</span>) * multiplicand-&gt;col + k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt;= multiplier-&gt;col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                new-&gt;data[(i - <span class="number">1</span>) * new-&gt;col + j - <span class="number">1</span>] += t * multiplier-&gt;data[(k - <span class="number">1</span>) * multiplier-&gt;col + j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了<del>已经敲到不能再熟的</del>报错环节，由于项目对效率要求并不高，因此矩阵乘法依然使用的是$O(n^3)$的传统矩阵乘法，但使用了$ikj$的三层循环顺序，可以较好地提高内存访问的连续性，具体原理参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/146250334">知乎用户@寨森Lambda-CDM的文章</a>。下图是摘自文章的各个循环顺序的内存访问跳跃数列表，作为参考：</p>
<p><img src="https://s2.loli.net/2022/10/29/ISBDZ7X1WxdnrPi.png" alt="不同循环顺序的条约次数"></p>
<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>喜闻乐见的快速幂环节，具体原理为将指数二进制表示后，通过倍乘<code>base</code>矩阵将乘法次数优化到<code>log(power)</code>次，对于$O(n^3)$的矩阵乘法而言优化力度较为客观，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Matrix *<span class="title function_">matrix_pow</span><span class="params">(Matrix *base, <span class="type">int</span> power)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>, <span class="string">&quot;The pointer to base matrix is null, power process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (power == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> create_copy(base);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;row != base-&gt;col)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;Illegal matrix shape&quot;</span>, <span class="string">&quot;The base matrix should be square matrix.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (power == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> create_identity(base-&gt;row);</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *new;</span><br><span class="line">    <span class="keyword">if</span> (power &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        new = create_copy(inverse(base));</span><br><span class="line">        <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print_error(<span class="string">&quot;NULL pointer exception&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;The source matrix has no inverse, negative power calculation interrupted.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        power = -power;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        new = create_copy(base);</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *Base = create_copy(base);</span><br><span class="line">    power--;<span class="comment">//因为new本来就是base一次方了所以-1</span></span><br><span class="line">    <span class="keyword">while</span> (power)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (power &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            multiply_by(&amp;new, Base);</span><br><span class="line">        &#125;</span><br><span class="line">        multiply_by(&amp;Base, Base);</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，矩阵的幂运算在正整数之外并没有定义，本项目中为了便利，将矩阵的幂的定义进行拓展：</p>
<p>若矩阵为方阵，则其0次幂为单位阵；</p>
<p>若矩阵为方阵且可逆，则其负数次幂为其逆的对应正数次幂。</p>
<hr>
<h3 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Functions For Matrix Transformations</span></span><br><span class="line">TYPE <span class="title function_">determinant</span><span class="params">(Matrix *pmat)</span>;</span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">inverse</span><span class="params">(Matrix *pmat)</span>;</span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">transpose</span><span class="params">(Matrix *pmat)</span>;</span><br><span class="line"></span><br><span class="line">Matrix *<span class="title function_">Uptriangular</span><span class="params">(Matrix *pmat)</span>;</span><br></pre></td></tr></table></figure>
<p>本节包含矩阵专属的一些常用函数：求行列式、求逆、转置、上三角化，求行列式和求逆均依赖上三角化进行。</p>
<h3 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Matrix *<span class="title function_">transpose</span><span class="params">(Matrix *pmat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pmat == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>, <span class="string">&quot;The pointer to source matrix is null, transpose process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *new = create_empty(pmat-&gt;col, pmat-&gt;row);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pmat-&gt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; pmat-&gt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(new-&gt;data + j * new-&gt;col + i) = *(pmat-&gt;data + i * pmat-&gt;col + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>行列交换即可。</p>
<h3 id="上三角化"><a href="#上三角化" class="headerlink" title="上三角化"></a>上三角化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Matrix *<span class="title function_">Uptriangular</span><span class="params">(Matrix *pmat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pmat == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The pointer to source matrix is null, uptriangular process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *new = create_copy(pmat);</span><br><span class="line">    <span class="type">size_t</span> lim = new-&gt;row &lt; new-&gt;col ? new-&gt;row : new-&gt;col;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (float_equal(new-&gt;data[i * new-&gt;col + i], <span class="number">0.0f</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = i + <span class="number">1</span>; j &lt; new-&gt;row; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!float_equal(new-&gt;data[j * new-&gt;col + i], <span class="number">0.0f</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; new-&gt;col; k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        TYPE t = new-&gt;data[i * new-&gt;col + k];</span><br><span class="line">                        new-&gt;data[i * new-&gt;col + k] = new-&gt;data[j * new-&gt;col + k];</span><br><span class="line">                        new-&gt;data[j * new-&gt;col + k] = t;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (float_equal(new-&gt;data[i * new-&gt;col + i], <span class="number">0.0f</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = i + <span class="number">1</span>; j &lt; new-&gt;row; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            TYPE t = new-&gt;data[j * new-&gt;col + i] / new-&gt;data[i * new-&gt;col + i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; new-&gt;col; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                new-&gt;data[j * new-&gt;col + k] -= new-&gt;data[i * new-&gt;col + k] * t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *res = create_full(new-&gt;row, new-&gt;col, <span class="number">0.0f</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>, it = <span class="number">0</span>; i &lt; new-&gt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> emp = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; new-&gt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(float_equal(new-&gt;data[i * new-&gt;col + j], <span class="number">0.0f</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                res-&gt;data[it * res-&gt;col + j] = new-&gt;data[i * new-&gt;col + j];</span><br><span class="line">                emp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it += emp ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delete_matrix(&amp;new);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上三角化是线性代数第一课就会讲的内容，也是线性代数大部分变换的基础，实现后求逆、求行列式等操作则迎刃而解。</p>
<p>上三角化的主要步骤为：</p>
<ol>
<li><p>检查报错，记录行数与列数中较小的一个作为循环上界</p>
</li>
<li><p>按列进行，对于矩阵$A$的第$i$列：</p>
<ul>
<li><p>若$A[i][i]$非零，则将其下方的所有行减去其倍数，直到$A[i][i]$下方所有元素消为0</p>
</li>
<li><p>若$A[i][i]=0$，则向下寻找第一个$j&gt;i$使得$A[j][i]≠0$，交换第$i$行和第$j$行</p>
</li>
<li>若到达最后一行仍没有找到，则说明该列主元缺失，$rank—$</li>
</ul>
</li>
<li><p>减除完毕后，部分全零行会存在矩阵中，此时将全零行下沉到矩阵最下方，得到完整的上三角矩阵$U$。</p>
</li>
<li>释放临时矩阵，返回结果</li>
</ol>
<h3 id="矩阵求秩"><a href="#矩阵求秩" class="headerlink" title="矩阵求秩"></a>矩阵求秩</h3><p>矩阵的秩经过基础行变换不会变化，因此我们只需统计上三角化后的矩阵的非零行数量即可。</p>
<h3 id="矩阵求行列式"><a href="#矩阵求行列式" class="headerlink" title="矩阵求行列式"></a>矩阵求行列式</h3><p>对矩阵进行除了换行以外的初等行变换不会影响矩阵的行列式，换行操作会使行列式变为相反数，因此在上三角化的过程中，我们只需记录换行的次数，并对上三角阵$U$的对角元素进行累乘运算即可得到矩阵的行列式。</p>
<p>代码较上三角化仅添加了几行(换行时记录符号，最后累乘)，此处不费篇幅展示。</p>
<h3 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Matrix *<span class="title function_">inverse</span><span class="params">(Matrix *pmat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pmat == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The pointer to source matrix is null, inverse calculation interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pmat-&gt;row != pmat-&gt;col)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;Illegal matrix shape&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The matrix should be square to have inverse, inverse calculation interrupted.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *new = row_concat(pmat, create_identity(pmat-&gt;row));</span><br><span class="line">    <span class="type">size_t</span> row = pmat-&gt;row;</span><br><span class="line">    <span class="type">size_t</span> col = row * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (float_equal(new-&gt;data[i * col + i], <span class="number">0.0f</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = i + <span class="number">1</span>; j &lt; row; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!float_equal(new-&gt;data[j * col + i], <span class="number">0.0f</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; col; k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        TYPE t = new-&gt;data[i * col + k];</span><br><span class="line">                        new-&gt;data[i * col + k] = new-&gt;data[j * col + k];</span><br><span class="line">                        new-&gt;data[j * col + k] = t;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (float_equal(new-&gt;data[i * col + i], <span class="number">0.0f</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            print_error(<span class="string">&quot;Inverse doesn&#x27;t exist&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;The rank of source matrix is not full, inverse calculation interrupted.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = i + <span class="number">1</span>; j &lt; row; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            TYPE t = new-&gt;data[j * col + i] / new-&gt;data[i * col + i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; col; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                new-&gt;data[j * col + k] -= new-&gt;data[i * col + k] * t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        TYPE u = new-&gt;data[i * col + i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            TYPE v = new-&gt;data[j * col + i] / u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> k = i; k &lt; col; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                new-&gt;data[j * col + k] -= new-&gt;data[i * col + k] * v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        TYPE t = new-&gt;data[i * col + i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = row; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new-&gt;data[i * new-&gt;col + j] /= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sub_matrix(new, <span class="number">1</span>, pmat-&gt;col + <span class="number">1</span>, new-&gt;row, new-&gt;col);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成了上三角化，我们可以用$Gauss\ Jordan\ Elimination$进行矩阵求逆：</p>
<ol>
<li><p>检查报错，记录行数与列数中较小的一个作为循环上界</p>
</li>
<li><p>在原矩阵的右侧拼合一个同阶单位矩阵，与原矩阵进行同样的行变换</p>
</li>
<li><p>按列进行，对于矩阵$A$的第$i$列：</p>
<ul>
<li><p>若$A[i][i]$非零，则将其下方的所有行减去其倍数，直到$A[i][i]$下方所有元素消为0</p>
</li>
<li><p>若$A[i][i]=0$，则向下寻找第一个$j&gt;i$使得$A[j][i]≠0$，交换第$i$行和第$j$行</p>
</li>
<li>若到达最后一行仍没有找到，则说明该列主元缺失，矩阵不满秩，不存在逆，<strong>返回空指针</strong></li>
</ul>
</li>
<li><p>减除完毕后，有逆的矩阵不存在全零行，得到上三角矩阵$U$</p>
</li>
<li><p>按列反向进行，对于矩阵$A$的第$i$列，将$A[i][i]$上方的所有行减去其倍数直到消为0</p>
</li>
<li><p>上一步完成后，拼合矩阵的左侧为对角阵，对于每一行除以其主元$A[i][i]$即可</p>
</li>
<li>利用<code>sub_matrix</code>函数截取起初拼合在右侧的单位矩阵，此时经过行变换已经变成了矩阵的逆</li>
<li>返回结果</li>
</ol>
<hr>
<h3 id="报错与警告"><a href="#报错与警告" class="headerlink" title="报错与警告"></a>报错与警告</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Functions For Debugging, Error &amp; Warning</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_matrix</span><span class="params">(Matrix *pmat, <span class="type">int</span> precision)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_error</span><span class="params">(<span class="type">char</span> *err_type, <span class="type">char</span> *err_info)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_warning</span><span class="params">(<span class="type">char</span> *w_type, <span class="type">char</span> *w_info)</span>;</span><br></pre></td></tr></table></figure>
<p>本项目中，参数列表带有矩阵的函数均有报错/警告语句，为了综合报错和警告而非排布<code>printf</code>语句，本项目使用两个函数进行规范化报错和警告，分为类型和具体信息两部分，内容详细具体。</p>
<h3 id="输出矩阵"><a href="#输出矩阵" class="headerlink" title="输出矩阵"></a>输出矩阵</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_matrix</span><span class="params">(Matrix *pmat, <span class="type">int</span> precision)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pmat == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>, <span class="string">&quot;The pointer to source matrix is null, print process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;Illegal precision&quot;</span>, <span class="string">&quot;Precision should be non-negative, print process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (precision &gt; <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_warning(<span class="string">&quot;Precision too large&quot;</span>, <span class="string">&quot;Float numbers are accurate to at most the 6th decimal place.&quot;</span>);</span><br><span class="line">        precision = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pmat-&gt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; pmat-&gt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (float_equal(pmat-&gt;data[i * pmat-&gt;col + j], <span class="number">0.0f</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                pmat-&gt;data[i * pmat-&gt;col + j] = <span class="number">0.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.*f\t&quot;</span>, precision, pmat-&gt;data[i * pmat-&gt;col + j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到用户可能并不是每次都想输出小数点后6位数字，继承前两次project优良传统的笔者给输出函数加了精度参数，如果只是整数级别的运算就没必要显示小数点后了嘛。</p>
<p>不过就算把<code>precision</code>设置为114514，囿于<code>float</code>型的精度也只能精确到6位以内，因此程序在接收到高于6的精度要求后会抛个警告并坚持设置精度为6。</p>
<p>输出的部分也是朴素安全，在调试时笔者注意到一个细节：有时候会输出<code>-0.0</code>这样的数据，看上去很怪，这是因为没有显示完全一个很接近0的负数，所以采用了<code>float_equal</code>进行处理，顺便把原矩阵的值也修改为常规的<code>0.0f</code>。</p>
<h3 id="输出矩阵到文件"><a href="#输出矩阵到文件" class="headerlink" title="输出矩阵到文件"></a>输出矩阵到文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">print_matrix_to_file</span><span class="params">(<span class="type">char</span> *filename, Matrix *pmat, <span class="type">int</span> precision)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *file = fopen(filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The output file is not found, print to file process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pmat == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;NULL pointer exception&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The pointer to source matrix is null, print to file process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error(<span class="string">&quot;Illegal precision&quot;</span>, <span class="string">&quot;Precision should be non-negative, print to file process interrupted.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (precision &gt; <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_warning(<span class="string">&quot;Precision too large&quot;</span>, <span class="string">&quot;Float numbers are accurate to at most the 6th decimal place.&quot;</span>);</span><br><span class="line">        precision = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pmat-&gt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; pmat-&gt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (float_equal(pmat-&gt;data[i * pmat-&gt;col + j], <span class="number">0.0f</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                pmat-&gt;data[i * pmat-&gt;col + j] = <span class="number">0.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fprintf</span>(file, <span class="string">&quot;%.*f\t&quot;</span>, precision, pmat-&gt;data[i * pmat-&gt;col + j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(file, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于规模较大的矩阵，用户会有将结果输出到指定文件的需求，本项目也进行了实现。</p>
<h2 id="Part-3-Result-amp-Verification"><a href="#Part-3-Result-amp-Verification" class="headerlink" title="Part 3 - Result &amp; Verification"></a>Part 3 - Result &amp; Verification</h2><h3 id="Testcase-1-创建矩阵"><a href="#Testcase-1-创建矩阵" class="headerlink" title="Testcase #1 创建矩阵"></a>Testcase #1 创建矩阵</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *mat = create_full(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    print_matrix(mat, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    delete_matrix(&amp;mat);</span><br><span class="line"></span><br><span class="line">    TYPE arr[] = &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    mat = create_from_array(arr, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    print_matrix(mat, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    delete_matrix(&amp;mat);</span><br><span class="line"></span><br><span class="line">    mat = create_from_string(<span class="string">&quot;1,1,4;5,1,4&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    print_matrix(mat, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    delete_matrix(&amp;mat);</span><br><span class="line"></span><br><span class="line">    Matrix *mat2 = create_copy(mat);</span><br><span class="line">    delete_matrix(&amp;mat);</span><br><span class="line">    print_matrix(mat2, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    delete_matrix(&amp;mat2);</span><br><span class="line"></span><br><span class="line">    mat = create_identity(<span class="number">3</span>);</span><br><span class="line">    print_matrix(mat, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    delete_matrix(&amp;mat);</span><br><span class="line"></span><br><span class="line">    mat= create_random(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">    print_matrix(mat, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    delete_matrix(&amp;mat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/29/jgWrmOKsMZPNiHv.png" alt="create.png" style="zoom:50%;" /></p>
<hr>
<h3 id="Testcase-2-矩阵级别操作"><a href="#Testcase-2-矩阵级别操作" class="headerlink" title="Testcase #2 矩阵级别操作"></a>Testcase #2 矩阵级别操作</h3><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *mat = create_full(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1.2</span>);</span><br><span class="line">    print_matrix(mat, <span class="number">1</span>);</span><br><span class="line">    delete_matrix(&amp;mat);</span><br><span class="line">    print_matrix(mat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/29/KC4NxfWbXqAr9HY.png" alt="delete.png"></p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    TYPE arr[] = &#123;<span class="number">0.1</span>, <span class="number">-0.2</span>, <span class="number">0.3</span>, <span class="number">-0.4</span>&#125;;</span><br><span class="line">    Matrix *mat = create_from_array(arr, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Matrix *cpy=<span class="literal">NULL</span>;</span><br><span class="line">    Matrix *ref=<span class="literal">NULL</span>;</span><br><span class="line">    copy_matrix(&amp;cpy,mat);</span><br><span class="line">    ref_matrix(&amp;ref,mat);</span><br><span class="line">    set_value(mat,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;copy:\n&quot;</span>);</span><br><span class="line">    print_matrix(cpy,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;reference:\n&quot;</span>);</span><br><span class="line">    print_matrix(ref,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s2.loli.net/2022/10/29/UW7Qe1SyVT62hBX.png" alt="copy.png"></p>
<h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *mat = create_from_string(<span class="string">&quot;1,1,2;3,5,8;13,21,34;55,89,144&quot;</span>,<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    Matrix *i3=create_identity(<span class="number">3</span>);</span><br><span class="line">    Matrix *i4=create_identity(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;col_concat:\n&quot;</span>);</span><br><span class="line">    print_matrix(col_concat(mat,i3),<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;row_concat:\n&quot;</span>);</span><br><span class="line">    print_matrix(row_concat(i4,mat),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/29/FNXEbCLoKOWUxgJ.png" alt="concat.png" style="zoom:50%;" /></p>
<hr>
<h3 id="Testcase-3-矩阵查询"><a href="#Testcase-3-矩阵查询" class="headerlink" title="Testcase #3 矩阵查询"></a>Testcase #3 矩阵查询</h3><h4 id="自定义最值-从文件中读取"><a href="#自定义最值-从文件中读取" class="headerlink" title="自定义最值(从文件中读取)"></a>自定义最值(从文件中读取)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//matfile</span></span><br><span class="line"><span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>;</span><br><span class="line"><span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>;</span><br><span class="line"><span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>;</span><br><span class="line"><span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>;</span><br><span class="line"><span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (customized compare function &amp; main function)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">mycmp</span><span class="params">(TYPE x,TYPE y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(x<span class="number">-2.1</span>)&lt;<span class="built_in">fabs</span>(y<span class="number">-2.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *mat=create_from_file(<span class="string">&quot;matfile&quot;</span>,<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    print_matrix(mat,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The max value is %.1f\nThe min value is %.1f\n&quot;</span>,max(mat),min(mat));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value closest to 2.1 is %.1f\n&quot;</span>,extreme_value(mat,mycmp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/qmQKaxO95sT14nC.png" alt="extrema.png" style="zoom: 67%;" /></p>
<hr>
<h3 id="Testcase-4-自定义矩阵运算"><a href="#Testcase-4-自定义矩阵运算" class="headerlink" title="Testcase #4 自定义矩阵运算"></a>Testcase #4 自定义矩阵运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *mat=create_from_file(<span class="string">&quot;matfile&quot;</span>,<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;origin mat:\n&quot;</span>);</span><br><span class="line">    print_matrix(mat,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;unary operation mat:\n&quot;</span>);</span><br><span class="line">    Matrix *una=unary_calc(mat,cosf);</span><br><span class="line">    print_matrix(una,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;binary operation mat:\n&quot;</span>);</span><br><span class="line">    Matrix *bin=binary_calc(mat,una,divide);</span><br><span class="line">    print_matrix(bin,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scalar operation mat:\n&quot;</span>);</span><br><span class="line">    Matrix *sca=scalar_calc(mat,<span class="number">6</span>,minus);</span><br><span class="line">    print_matrix(sca,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/eFrIh8cDbTSfOAQ.png" alt="image.png" style="zoom:50%;" /></p>
<hr>
<h3 id="Testcase-5-矩阵计算"><a href="#Testcase-5-矩阵计算" class="headerlink" title="Testcase #5 矩阵计算"></a>Testcase #5 矩阵计算</h3><h4 id="简单运算"><a href="#简单运算" class="headerlink" title="简单运算"></a>简单运算</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    Matrix *A=create_random(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A:\n&quot;</span>);</span><br><span class="line">    print_matrix(A,<span class="number">2</span>);</span><br><span class="line">    Matrix *B=create_random(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B:\n&quot;</span>);</span><br><span class="line">    print_matrix(B,<span class="number">2</span>);</span><br><span class="line">    multiply_by(&amp;A,B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A=A*B=\n&quot;</span>);</span><br><span class="line">    print_matrix(A,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A+B=\n&quot;</span>);</span><br><span class="line">    print_matrix(matrix_add(A,B),<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A-B=\n&quot;</span>);</span><br><span class="line">    print_matrix(matrix_subtract(A,B),<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/Vi9kB5tTDgGz1w8.png" alt="basic_calc.png" style="zoom:50%;" /></p>
<h4 id="矩阵加速斐波那契数列"><a href="#矩阵加速斐波那契数列" class="headerlink" title="矩阵加速斐波那契数列"></a>矩阵加速斐波那契数列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *A=create_from_string(<span class="string">&quot;1,1;1,0&quot;</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    Matrix *v=create_from_string(<span class="string">&quot;1;1&quot;</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix *t=matrix_multiply(matrix_pow(A,i),v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fib[%d] = %.0f\n&quot;</span>,i,get_value(t,<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/z9MgQqcWDFhk2HT.png" alt="fib.png" style="zoom:50%;" /></p>
<hr>
<h3 id="Testcase-6-矩阵变换"><a href="#Testcase-6-矩阵变换" class="headerlink" title="Testcase #6 矩阵变换"></a>Testcase #6 矩阵变换</h3><h4 id="上三角化，行列式，逆"><a href="#上三角化，行列式，逆" class="headerlink" title="上三角化，行列式，逆"></a>上三角化，行列式，逆</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *A=create_random(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A:\n&quot;</span>);</span><br><span class="line">    print_matrix(A,<span class="number">2</span>);</span><br><span class="line">    Matrix *U=Uptriangular(A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;U:\n&quot;</span>);</span><br><span class="line">    print_matrix(U,<span class="number">2</span>);</span><br><span class="line">    Matrix *I=inverse(A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A^-1:\n&quot;</span>);</span><br><span class="line">    print_matrix(I,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A*(A^-1)=\n&quot;</span>);</span><br><span class="line">    print_matrix(matrix_multiply(A,I),<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;|A| = %f\n&quot;</span>,determinant(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/rmu34DqKpo7nGB2.png" alt="trans.png" style="zoom:50%;" /></p>
<h4 id="不满秩矩阵"><a href="#不满秩矩阵" class="headerlink" title="不满秩矩阵"></a>不满秩矩阵</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//matfile</span></span><br><span class="line"><span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span></span><br><span class="line"><span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *not_full_rank_mat=create_from_file(<span class="string">&quot;matfile&quot;</span>,<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not full rank matrix:\n&quot;</span>);</span><br><span class="line">    print_matrix(not_full_rank_mat,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inverse:\n&quot;</span>);</span><br><span class="line">    print_matrix(inverse(not_full_rank_mat),<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;determinant: %.0f\n&quot;</span>,determinant(not_full_rank_mat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/OBfg7usEH9AVkNi.png" alt="image.png" style="zoom:50%;" /></p>
<h4 id="转置与秩"><a href="#转置与秩" class="headerlink" title="转置与秩"></a>转置与秩</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *A=create_from_file(<span class="string">&quot;matfile&quot;</span>,<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A:\n&quot;</span>);</span><br><span class="line">    print_matrix(A,<span class="number">0</span>);</span><br><span class="line">    Matrix *T=transpose(A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T:\n&quot;</span>);</span><br><span class="line">    print_matrix(T,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The rank of A is: %d\nThe rank of T is: %d\n&quot;</span>,rank(A),rank(T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/RvWqULAaYg1tJQn.png" alt="image.png" style="zoom:50%;" /></p>
<hr>
<h3 id="Testcase-7-鲁棒性测试"><a href="#Testcase-7-鲁棒性测试" class="headerlink" title="Testcase #7 鲁棒性测试"></a>Testcase #7 鲁棒性测试</h3><h4 id="创建矩阵-1"><a href="#创建矩阵-1" class="headerlink" title="创建矩阵"></a>创建矩阵</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请不合法空间</span></span><br><span class="line">    Matrix *too_large=create_empty(<span class="number">10000</span>,<span class="number">10001</span>);</span><br><span class="line">    Matrix *too_small=create_empty(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//空数组作为数据源</span></span><br><span class="line">    TYPE *arr=<span class="literal">NULL</span>;</span><br><span class="line">    Matrix *null_src=create_from_array(arr,<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//试图拷贝null数组</span></span><br><span class="line">    Matrix *copy_null=create_copy(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//错误格式的字符串作为数据源</span></span><br><span class="line">    Matrix *wrong_str=create_from_string(<span class="string">&quot;1,2,3;4,5;&quot;</span>,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//不存在的文件作为数据源</span></span><br><span class="line">    Matrix *file_404=create_from_file(<span class="string">&quot;file.404&quot;</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//截取超出原矩阵的子矩阵</span></span><br><span class="line">    Matrix *ori=create_full(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    Matrix *sub=sub_matrix(ori,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/xsZzMyaATJX7BUF.png" alt="robust_create.png" style="zoom:50%;" /></p>
<p>(*每个函数都内置了空指针报错，后续不作重复展示)</p>
<h4 id="矩阵级别操作-1"><a href="#矩阵级别操作-1" class="headerlink" title="矩阵级别操作"></a>矩阵级别操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//二次删除</span></span><br><span class="line">    Matrix *A = create_full(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Matrix *B = create_full(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    Matrix *C = create_full(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    delete_matrix(&amp;A);</span><br><span class="line">    delete_matrix(&amp;A);</span><br><span class="line">    <span class="comment">// null作为源的拷贝</span></span><br><span class="line">    copy_matrix(&amp;B, A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B:\n&quot;</span>);</span><br><span class="line">    print_matrix(B, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//覆盖null的拷贝</span></span><br><span class="line">    copy_matrix(&amp;A, B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A:\n&quot;</span>);</span><br><span class="line">    print_matrix(A, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//大小不匹配时的警告</span></span><br><span class="line">    copy_matrix(&amp;A, C);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A:\n&quot;</span>);</span><br><span class="line">    print_matrix(A,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//按列拼合两个列数不同的矩阵</span></span><br><span class="line">    Matrix *cat=col_concat(A,B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/r2tpMAf7mnSekV3.png" alt="robust_del_cpy.png"></p>
<h4 id="矩阵运算-修改传入值"><a href="#矩阵运算-修改传入值" class="headerlink" title="矩阵运算(修改传入值)"></a>矩阵运算(修改传入值)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//被加数为空</span></span><br><span class="line">    Matrix *A=<span class="literal">NULL</span>;</span><br><span class="line">    Matrix *B=create_full(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A=0+B=\n&quot;</span>);</span><br><span class="line">    add_by(&amp;A,B);</span><br><span class="line">    print_matrix(A,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//被减数为空</span></span><br><span class="line">    B=<span class="literal">NULL</span>;</span><br><span class="line">    subtract_by(&amp;B,A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B=0-A=\n&quot;</span>);</span><br><span class="line">    print_matrix(B,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/AMyiL6RSBpVwlnv.png" alt="image.png"></p>
<h4 id="矩阵计算-1"><a href="#矩阵计算-1" class="headerlink" title="矩阵计算"></a>矩阵计算</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *A = create_full(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Matrix *B = create_full(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//不同形状的矩阵相加</span></span><br><span class="line">    Matrix *C = matrix_add(A, B);</span><br><span class="line">    <span class="comment">//不合法的矩阵相乘</span></span><br><span class="line">    C = matrix_multiply(A, B);</span><br><span class="line">    <span class="comment">//非方阵的矩阵幂</span></span><br><span class="line">    C = matrix_pow(A, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//逆不存在时的负数幂</span></span><br><span class="line">    C=matrix_pow(B,<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/Jx2N4SXjBUD5lw8.png" alt="robust_calc.png"></p>
<h4 id="矩阵变换-1"><a href="#矩阵变换-1" class="headerlink" title="矩阵变换"></a>矩阵变换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Benchmark.c (main function)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix *A = create_full(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Matrix *B = create_full(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//非方阵求逆</span></span><br><span class="line">    Matrix *I=inverse(A);</span><br><span class="line">    <span class="comment">//非方阵求行列式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;detA=%f\n&quot;</span>,determinant(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result: </p>
<p><img src="https://s2.loli.net/2022/10/30/hdIanKWlCuwJDom.png" alt="robust_trans.png"></p>
<h2 id="Part-4-Difficulties-amp-Solutions"><a href="#Part-4-Difficulties-amp-Solutions" class="headerlink" title="Part 4 - Difficulties &amp; Solutions"></a>Part 4 - Difficulties &amp; Solutions</h2><h3 id="1-安全、报错与警告"><a href="#1-安全、报错与警告" class="headerlink" title="1. 安全、报错与警告"></a>1. 安全、报错与警告</h3><p><strong>需求</strong>：由于项目需要实现一个安全的库，不至于用户正常操作导致崩溃，因此对于可能的危险操作要进行检查、报错和处理。</p>
<p><strong>解决方案</strong>：</p>
<p>​        标准库中，一个函数有时会有对应的<code>safe</code>版本，以效率作为代价提高安全性。本项目根据情景需求，将所有函数按<code>safe</code>标准编写，对于每个函数都内置内存管理、指针操作等细节，用户直接调用函数即可。</p>
<p>​        由于C并不能便捷地通过<code>throw catch</code>来捕获错误，本项目中在每个函数中，在进行函数操作前都使用判断语句检查安全性，若有错误则及时返回并报错/警告，报错/警告通过综合的函数实现。同时，丰富的函数接口覆盖了用户对于矩阵操作的需求，可以便利地使用，避免了用户直接对矩阵进行内存管理而可能导致的高危隐患。</p>
<h3 id="2-移植性与拓展性"><a href="#2-移植性与拓展性" class="headerlink" title="2. 移植性与拓展性"></a>2. 移植性与拓展性</h3><p><strong>需求</strong>：理工科在不同操作系统进行矩阵运算的情境下，经常需要对整个矩阵进行一元/二元的各种类型的运算，如果按照传统的方式，对于每一种运算都实现一个函数，则会导致库的冗余重复，调用时也很麻烦。</p>
<p><strong>解决方案</strong>：</p>
<p>​        可移植方面，本项目依据标准库模式使用<code>size_t</code>类型记录下标，既避免了负下标可能导致的段错误，也保证了不同位数操作系统下的一致性。</p>
<p>​        数据类型方面，囿于C语言的限制，本项目以宏丐版代替模板，模拟了类模板的效果，更改<code>TYPE</code>后只需要简单修改细节即可适用于不同类型的数据。</p>
<p>​        矩阵运算方面，本项目实现支持自定义运算的矩阵运算函数，对于用户自定义的任意一元/二元运算，只需要将运算的函数指针作为参数传入库内的函数，则可以对矩阵逐元素进行自定义运算，扩展性良好<del>，不能重载运算符的确让人挺难受的</del>。</p>
<h3 id="3-复杂函数的实现"><a href="#3-复杂函数的实现" class="headerlink" title="3. 复杂函数的实现"></a>3. 复杂函数的实现</h3><p><strong>需求</strong>：求行列式，求秩，求逆这三个问题与上三角化均有绑定关系，但上三角化的实现较为复杂。</p>
<p><strong>解决方案</strong>：回去翻了线性代数教材，手动模拟了几次$Gauss\ Jordan\ Elimination$，然后将模拟的过程在2h的debug后码出来了，前三个问题也迎刃而解，实现这个之后，矩阵的若干种其他分解要实现也很轻松了。</p>
<h2 id="Part-5-Summary"><a href="#Part-5-Summary" class="headerlink" title="Part 5 - Summary"></a>Part 5 - Summary</h2><p>​        感谢您能读到这里，报告为了尽力展示项目全貌略显冗长，下次改正，感谢理解（磕头</p>
<p>​        和前两次project不同，这次笔者先没有直接开写，而是首先观摩了<a target="_blank" rel="noopener" href="https://github.com/Amoiensis/Matrix_hub">GitHub上Amoiensis的Matrix_hub项目</a>，了解了矩阵运算常用的需求，对照题目构思了可能可以实现的功能以及相比他的项目我可以做出的改进。也因此，在项目的实现中并非想到一个函数就写一个，加入了很多扩展性的内容。</p>
<p>​        本次project对于安全性的要求较高，笔者也因此再次加强了对程序鲁棒性的要求，在没有<code>try catch</code>的帮助下进行<code>error handling</code>确实是个技术活，在编写过程中也有参考大家讨论中提出的异常情况来进行优化。</p>
<p>​        感觉这次project的主要难点在要自己给自己出难题(实际上这学期的project都有这个成分在的)，对于加深C的理解还是很有帮助的，不过对于初学者来说可能是个不小的挑战吧(笑)。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/05/CS205_%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A_Simple_Calculator/" rel="prev" title="CS205 C/C++ Project02设计报告 简易计算器">
      <i class="fa fa-chevron-left"></i> CS205 C/C++ Project02设计报告 简易计算器
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/06/CS211_%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A_Flappy_Bird/" rel="next" title="CS211 数字逻辑 (H) 项目设计报告 Flappy Bird">
      CS211 数字逻辑 (H) 项目设计报告 Flappy Bird <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <div id="gitalk-container"></div>
  <script>
  const gitalk = new Gitalk({
    clientID: '79118b0b29b4170f24af',
    clientSecret: '48ee47026d13b8a3a954b2b089ea320510282527',
    repo: 'GuTaoZi.github.io',      // The repository of store comments,
    owner: 'GuTaoZi',
    admin: ['GuTaoZi'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
  </script>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-0-%E5%9B%A2%E9%98%9F%E6%88%90%E5%91%98"><span class="nav-number">1.</span> <span class="nav-text">Part 0. 团队成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">项目结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-1-Analysis"><span class="nav-number">2.</span> <span class="nav-text">Part 1 - Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E9%87%8D%E8%BF%B0-amp-%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF"><span class="nav-number">2.1.</span> <span class="nav-text">题目重述&amp;主要思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%81%87%E8%AE%BE"><span class="nav-number">2.2.</span> <span class="nav-text">模型假设</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-2-Code"><span class="nav-number">3.</span> <span class="nav-text">Part 2 - Code</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.1.</span> <span class="nav-text">宏与结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%9F%A9%E9%98%B5"><span class="nav-number">3.2.</span> <span class="nav-text">创建矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E7%BA%A7%E5%88%AB%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.</span> <span class="nav-text">矩阵级别操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%9F%A9%E9%98%B5"><span class="nav-number">3.4.</span> <span class="nav-text">删除矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%9F%A9%E9%98%B5"><span class="nav-number">3.5.</span> <span class="nav-text">复制矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">3.6.</span> <span class="nav-text">拼接矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">3.7.</span> <span class="nav-text">查询操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%80%E5%80%BC"><span class="nav-number">3.8.</span> <span class="nav-text">自定义最值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97"><span class="nav-number">3.9.</span> <span class="nav-text">自定义矩阵运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97"><span class="nav-number">3.10.</span> <span class="nav-text">矩阵计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">3.11.</span> <span class="nav-text">矩阵快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2"><span class="nav-number">3.12.</span> <span class="nav-text">矩阵变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE"><span class="nav-number">3.13.</span> <span class="nav-text">矩阵转置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%89%E8%A7%92%E5%8C%96"><span class="nav-number">3.14.</span> <span class="nav-text">上三角化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%B1%82%E7%A7%A9"><span class="nav-number">3.15.</span> <span class="nav-text">矩阵求秩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="nav-number">3.16.</span> <span class="nav-text">矩阵求行列式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86"><span class="nav-number">3.17.</span> <span class="nav-text">矩阵求逆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%A5%E9%94%99%E4%B8%8E%E8%AD%A6%E5%91%8A"><span class="nav-number">3.18.</span> <span class="nav-text">报错与警告</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E7%9F%A9%E9%98%B5"><span class="nav-number">3.19.</span> <span class="nav-text">输出矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E7%9F%A9%E9%98%B5%E5%88%B0%E6%96%87%E4%BB%B6"><span class="nav-number">3.20.</span> <span class="nav-text">输出矩阵到文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-3-Result-amp-Verification"><span class="nav-number">4.</span> <span class="nav-text">Part 3 - Result &amp; Verification</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Testcase-1-%E5%88%9B%E5%BB%BA%E7%9F%A9%E9%98%B5"><span class="nav-number">4.1.</span> <span class="nav-text">Testcase #1 创建矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Testcase-2-%E7%9F%A9%E9%98%B5%E7%BA%A7%E5%88%AB%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.</span> <span class="nav-text">Testcase #2 矩阵级别操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">4.2.1.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6"><span class="nav-number">4.2.2.</span> <span class="nav-text">复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5"><span class="nav-number">4.2.3.</span> <span class="nav-text">拼接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Testcase-3-%E7%9F%A9%E9%98%B5%E6%9F%A5%E8%AF%A2"><span class="nav-number">4.3.</span> <span class="nav-text">Testcase #3 矩阵查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%80%E5%80%BC-%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96"><span class="nav-number">4.3.1.</span> <span class="nav-text">自定义最值(从文件中读取)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Testcase-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97"><span class="nav-number">4.4.</span> <span class="nav-text">Testcase #4 自定义矩阵运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Testcase-5-%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97"><span class="nav-number">4.5.</span> <span class="nav-text">Testcase #5 矩阵计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%BF%90%E7%AE%97"><span class="nav-number">4.5.1.</span> <span class="nav-text">简单运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">4.5.2.</span> <span class="nav-text">矩阵加速斐波那契数列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Testcase-6-%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2"><span class="nav-number">4.6.</span> <span class="nav-text">Testcase #6 矩阵变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E4%B8%89%E8%A7%92%E5%8C%96%EF%BC%8C%E8%A1%8C%E5%88%97%E5%BC%8F%EF%BC%8C%E9%80%86"><span class="nav-number">4.6.1.</span> <span class="nav-text">上三角化，行列式，逆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E6%BB%A1%E7%A7%A9%E7%9F%A9%E9%98%B5"><span class="nav-number">4.6.2.</span> <span class="nav-text">不满秩矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E7%BD%AE%E4%B8%8E%E7%A7%A9"><span class="nav-number">4.6.3.</span> <span class="nav-text">转置与秩</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Testcase-7-%E9%B2%81%E6%A3%92%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="nav-number">4.7.</span> <span class="nav-text">Testcase #7 鲁棒性测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%9F%A9%E9%98%B5-1"><span class="nav-number">4.7.1.</span> <span class="nav-text">创建矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E7%BA%A7%E5%88%AB%E6%93%8D%E4%BD%9C-1"><span class="nav-number">4.7.2.</span> <span class="nav-text">矩阵级别操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97-%E4%BF%AE%E6%94%B9%E4%BC%A0%E5%85%A5%E5%80%BC"><span class="nav-number">4.7.3.</span> <span class="nav-text">矩阵运算(修改传入值)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97-1"><span class="nav-number">4.7.4.</span> <span class="nav-text">矩阵计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2-1"><span class="nav-number">4.7.5.</span> <span class="nav-text">矩阵变换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-4-Difficulties-amp-Solutions"><span class="nav-number">5.</span> <span class="nav-text">Part 4 - Difficulties &amp; Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%89%E5%85%A8%E3%80%81%E6%8A%A5%E9%94%99%E4%B8%8E%E8%AD%A6%E5%91%8A"><span class="nav-number">5.1.</span> <span class="nav-text">1. 安全、报错与警告</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%A7%BB%E6%A4%8D%E6%80%A7%E4%B8%8E%E6%8B%93%E5%B1%95%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">2. 移植性与拓展性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.3.</span> <span class="nav-text">3. 复杂函数的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-5-Summary"><span class="nav-number">6.</span> <span class="nav-text">Part 5 - Summary</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="咕桃"
      src="https://avatars.githubusercontent.com/u/109007949?v=4">
  <p class="site-author-name" itemprop="name">咕桃</p>
  <div class="site-description" itemprop="description">Just Do It, But Not Just Do It.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GuTaoZi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GuTaoZi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:first_fan@outlook.com" title="E-Mail → mailto:first_fan@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">咕桃</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
